<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî Manual Counter</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:140px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;color:#111}
  .ok{color:#0a7;font-weight:800}
  .warn{color:#c90;font-weight:800}
</style>
</head>

<body>
<h1>MWC ‚Äî –†—É—á–Ω–æ–π –ø–æ–¥—Å—á—ë—Ç –≥—Ä–∏–±–æ–≤</h1>
<div class="small">
<b>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:</b> –∑–∞–≥—Ä—É–∑–∏–ª —Ñ–æ—Ç–æ ‚Üí —Ç–∞–ø–∞–π –ø–æ –∫–∞–∂–¥–æ–º—É –≥—Ä–∏–±—É (—Å—Ç–∞–≤–∏—Ç—Å—è –∫—Ä—É–∂–æ–∫) ‚Üí —Å–≤–µ—Ä—Ö—É –≤–∏–¥–∏—à—å –∏—Ç–æ–≥.<br>
<b>–ñ–µ—Å—Ç—ã:</b> Tap=–¥–æ–±–∞–≤–∏—Ç—å ‚Ä¢ Tap –ø–æ –∫—Ä—É–∂–∫—É=—É–¥–∞–ª–∏—Ç—å ‚Ä¢ Hold+Drag=–ø–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <div class="kv" id="status">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card">
  <b>–†–∞–∑–º–µ—Ç–∫–∞</b>
  <canvas id="cv"></canvas>
  <div class="small">üî¥ ‚Äî —Ç–≤–æ–∏ –º–µ—Ç–∫–∏ (–¥–∏–∞–º–µ—Ç—Ä +1 –º–º)</div>
</div>

<div class="card">
  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clear" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>
</div>

<script>
const input = document.getElementById("img");
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { willReadFrequently:true });

const statusEl = document.getElementById("status");
const undoBtn = document.getElementById("undo");
const clearBtn = document.getElementById("clear");
const exportBtn = document.getElementById("export");
const savePngBtn = document.getElementById("savepng");

let imgObj = null;
let marks = [];     // {x,y}
let history = [];   // stack of JSON strings
let dragging = false;
let dragIdx = -1;
let pressTimer = null;

/* ===========================
   –ù–ê–°–¢–†–û–ô–ö–ê –ú–ï–¢–ö–ò
   –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ: "–∫—Ä–∞—Å–Ω–∞—è" + "–¥–∏–∞–º–µ—Ç—Ä –±–æ–ª—å—à–µ –Ω–∞ 1 –º–º"
   –í —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –¥–µ–ª–∞–µ–º –ø—Ä–∞–∫—Ç–∏—á–Ω–æ:
   - –∫—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç
   - –¥–∏–∞–º–µ—Ç—Ä +1 –º–º ‚âà +4 px (–Ω–∞ —Ç–≤–æ–∏—Ö —Ñ–æ—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç)
   –ë—ã–ª–æ: —Ä–∞–¥–∏—É—Å 10px (–¥–∏–∞–º–µ—Ç—Ä 20px)
   –°—Ç–∞–ª–æ: —Ä–∞–¥–∏—É—Å 12px (–¥–∏–∞–º–µ—Ç—Ä 24px)  => +4px –ø–æ –¥–∏–∞–º–µ—Ç—Ä—É
=========================== */
const MARK_COLOR = "#ff0000"; // red
const MARK_RADIUS_PX = 12;   // –±—ã–ª–æ 10

// --- UI ---
function setStatus(text, cls=""){
  statusEl.className = "kv " + cls;
  statusEl.textContent = text;
}
function updateUI(){
  undoBtn.disabled = history.length === 0;
  clearBtn.disabled = marks.length === 0;
  exportBtn.disabled = marks.length === 0;
  savePngBtn.disabled = !imgObj;
}

// --- helpers ---
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}
function pushHistory(){
  history.push(JSON.stringify(marks));
  if(history.length > 120) history.shift();
  updateUI();
}
function canvasXY(ev){
  const r = cv.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cv.width  / r.width);
  const y = (ev.clientY - r.top)  * (cv.height / r.height);
  return {x,y};
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
function nearestMark(x,y, px=26){
  const p = {x,y};
  const max2 = px*px;
  let best = -1, bestD = 1e18;
  for(let i=0;i<marks.length;i++){
    const d = dist2(marks[i], p);
    if(d < max2 && d < bestD){ bestD = d; best = i; }
  }
  return best;
}

// --- draw ---
function draw(){
  if(!imgObj) return;

  ctx.drawImage(imgObj, 0, 0, cv.width, cv.height);

  ctx.lineWidth = 3;
  ctx.strokeStyle = MARK_COLOR; // red
  for(const m of marks){
    ctx.beginPath();
    ctx.arc(m.x, m.y, MARK_RADIUS_PX, 0, Math.PI*2);
    ctx.stroke();
  }

  setStatus(`–û—Ç–º–µ—á–µ–Ω–æ –≥—Ä–∏–±–æ–≤: ${marks.length}`, marks.length ? "ok" : "warn");
  updateUI();
}

// --- load image ---
input.addEventListener("change", async ()=>{
  marks = [];
  history = [];
  dragging = false;
  dragIdx = -1;

  try{
    imgObj = await fileToImg(input.files[0]);

    // fit canvas to image (limit width)
    const maxW = 1100;
    const sc = Math.min(1, maxW / imgObj.naturalWidth);
    cv.width  = Math.round(imgObj.naturalWidth * sc);
    cv.height = Math.round(imgObj.naturalHeight * sc);

    setStatus("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –¢–∞–ø–∞–π –ø–æ –≥—Ä–∏–±–∞–º, —á—Ç–æ–±—ã –æ—Ç–º–µ—Ç–∏—Ç—å.", "warn");
    draw();
  }catch(e){
    imgObj = null;
    setStatus("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "");
    updateUI();
  }
});

// --- actions ---
function addMark(x,y){
  pushHistory();
  marks.push({x,y});
  draw();
}
function removeMark(idx){
  if(idx < 0) return;
  pushHistory();
  marks.splice(idx, 1);
  draw();
}
function startDrag(x,y){
  const idx = nearestMark(x,y,26);
  if(idx < 0) return false;
  pushHistory();
  dragging = true;
  dragIdx = idx;
  return true;
}
function moveDrag(x,y){
  if(!dragging || dragIdx < 0) return;
  marks[dragIdx].x = x;
  marks[dragIdx].y = y;
  draw();
}
function endDrag(){
  dragging = false;
  dragIdx = -1;
}

// --- mouse support ---
cv.addEventListener("mousedown", (ev)=>{
  if(!imgObj) return;
  const p = canvasXY(ev);
  pressTimer = setTimeout(()=> startDrag(p.x,p.y), 180);
});
cv.addEventListener("mousemove", (ev)=>{
  if(!imgObj) return;
  if(!dragging) return;
  const p = canvasXY(ev);
  moveDrag(p.x,p.y);
});
cv.addEventListener("mouseup", (ev)=>{
  if(!imgObj) return;
  clearTimeout(pressTimer);

  const p = canvasXY(ev);
  if(dragging){
    endDrag();
    draw();
    return;
  }

  const idx = nearestMark(p.x,p.y,18);
  if(idx >= 0) removeMark(idx);
  else addMark(p.x,p.y);
});

// --- iOS touch support (reliable) ---
cv.addEventListener("touchstart", (ev)=>{
  if(!imgObj) return;
  ev.preventDefault();
  const t = ev.touches[0];
  const p = canvasXY(t);

  pressTimer = setTimeout(()=>{
    startDrag(p.x,p.y);
  }, 180);
}, {passive:false});

cv.addEventListener("touchmove", (ev)=>{
  if(!imgObj) return;
  ev.preventDefault();
  if(!dragging) return;
  const t = ev.touches[0];
  const p = canvasXY(t);
  moveDrag(p.x,p.y);
}, {passive:false});

cv.addEventListener("touchend", (ev)=>{
  if(!imgObj) return;
  ev.preventDefault();
  clearTimeout(pressTimer);

  if(dragging){
    endDrag();
    draw();
    return;
  }

  // treat as tap: remove if near, else add
  // use last known touch position from changedTouches
  const t = ev.changedTouches[0];
  const p = canvasXY(t);
  const idx = nearestMark(p.x,p.y,18);
  if(idx >= 0) removeMark(idx);
  else addMark(p.x,p.y);
}, {passive:false});

// --- buttons ---
undoBtn.addEventListener("click", ()=>{
  if(!history.length) return;
  marks = JSON.parse(history.pop());
  draw();
});
clearBtn.addEventListener("click", ()=>{
  if(!marks.length) return;
  pushHistory();
  marks = [];
  draw();
});
exportBtn.addEventListener("click", ()=>{
  const payload = {
    version: "MWC_MANUAL_COUNTER_v1",
    created_at: new Date().toISOString(),
    count: marks.length,
    marks: marks,
    mark_style: { color: MARK_COLOR, radius_px: MARK_RADIUS_PX }
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "mwc_manual_marks.json";
  a.click();
});
savePngBtn.addEventListener("click", ()=>{
  if(!imgObj) return;
  draw(); // ensure latest
  const a = document.createElement("a");
  a.href = cv.toDataURL("image/png");
  a.download = "mwc_manual_marked.png";
  a.click();
});

// init
updateUI();
</script>
</body>
</html>
