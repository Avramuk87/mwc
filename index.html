<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî A1.6 BLOB FINAL</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  input[type="range"]{width:100%}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:manipulation}
  .ok{color:#0a7;font-weight:700}
  .bad{color:#c00;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:160px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#333}
</style>
</head>

<body>
<h1>MWC ‚Äî A1.6 BLOB FINAL (—Ç–æ–ª—å–∫–æ 4‚Äì12 –º–º)</h1>
<div class="small">
–ú–µ—Ç–æ–¥: DoG blob detection (—É—Å—Ç–æ–π—á–∏–≤ –∫ —Ç–µ–∫—Å—Ç—É—Ä–µ/–º–∏—Ü–µ–ª–∏—é).<br>
–£–≥–ª—ã —Ä–∞–º–∫–∏: <b>–õ–í ‚Üí –ü–í ‚Üí –ü–ù ‚Üí –õ–ù</b>. –°—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ <b>4‚Äì12 –º–º</b> (–≤ —Ä–æ—Å—Ç).
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <div class="row">
    <button id="pick" class="secondary" disabled>–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞</button>
    <button id="run" disabled>–ê–Ω–∞–ª–∏–∑</button>
  </div>

  <label class="small"><b>Sensitivity</b> (–º–µ–Ω—å—à–µ = —Å—Ç—Ä–æ–∂–µ, –±–æ–ª—å—à–µ = –±–æ–ª—å—à–µ –ø–∏–Ω–æ–≤)</label>
  <input id="sens" type="range" min="1" max="20" value="8">
  <div class="small kv" id="sensVal">8</div>

  <div class="small" id="hint">–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card"><pre id="out">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</pre></div>

<div class="card">
  <b>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ (–≤—ã–±–æ—Ä —É–≥–ª–æ–≤)</b>
  <canvas id="src"></canvas>
  <div class="small">–ü–æ—Ä—è–¥–æ–∫: 1) –õ–í  2) –ü–í  3) –ü–ù  4) –õ–ù</div>
</div>

<div class="card">
  <b>–†–∞—Å–ø—Ä–µ–º–ª—ë–Ω–Ω–∞—è —Ä–∞–º–∫–∞ (800√ó800)</b>
  <canvas id="rect"></canvas>
  <div class="small">üü¢ ‚Äî –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–∏–Ω—ã 4‚Äì12 –º–º</div>
</div>

<script>
const input = document.getElementById("img");
const pickBtn = document.getElementById("pick");
const runBtn  = document.getElementById("run");
const hint = document.getElementById("hint");
const out  = document.getElementById("out");
const cSrc = document.getElementById("src");
const cRect= document.getElementById("rect");
const srcCtx = cSrc.getContext("2d", { willReadFrequently:true });
const rectCtx= cRect.getContext("2d", { willReadFrequently:true });
const sens = document.getElementById("sens");
const sensVal = document.getElementById("sensVal");

sens.addEventListener("input", ()=> sensVal.textContent = sens.value);

let imgObj = null;
let picking = false;
let corners = [];

const RECT = 800;
const FRAME_MM = 200;
const mmPerPx = FRAME_MM / RECT;      // 0.25 –º–º/px

// –î–∏–∞–ø–∞–∑–æ–Ω –ø–æ –º–º (—Ç–æ–ª—å–∫–æ —Ä–æ—Å—Ç)
const DMIN_MM = 4.0;
const DMAX_MM = 12.0;

// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Ä–∞–¥–∏—É—Å—ã –≤ –ø–∏–∫—Å–µ–ª—è—Ö
function rpxFromMm(dmm){ return (dmm/2) / mmPerPx; }
const RMIN = rpxFromMm(DMIN_MM); // ~8 px
const RMAX = rpxFromMm(DMAX_MM); // ~24 px

function setOut(t, cls=""){ out.className = cls; out.textContent = t; }
function updateUI(){
  pickBtn.disabled = !imgObj;
  runBtn.disabled = !(imgObj && corners.length === 4);
  if (!imgObj) hint.textContent = "–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.";
  else if (corners.length < 4) hint.textContent = "–ù–∞–∂–º–∏ ¬´–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞¬ª –∏ —Ç–∫–Ω–∏ 4 —É–≥–ª–∞.";
  else hint.textContent = "–ì–æ—Ç–æ–≤–æ. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.";
}

input.addEventListener("change", async () => {
  corners = []; picking = false;
  try{
    imgObj = await fileToImg(input.files[0]);
    drawSource();
    setOut("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –í—ã–±–µ—Ä–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏.", "warn");
  }catch(e){
    imgObj = null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "bad");
  }
  updateUI();
});

pickBtn.addEventListener("click", () => {
  corners = []; picking = true;
  setOut("–¢–∫–Ω–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏ (–õ–í‚Üí–ü–í‚Üí–ü–ù‚Üí–õ–ù).", "warn");
  drawSource(); updateUI();
});

cSrc.addEventListener("click", (ev) => {
  if (!picking) return;
  const r = cSrc.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cSrc.width  / r.width);
  const y = (ev.clientY - r.top)  * (cSrc.height / r.height);
  corners.push({x,y});
  drawSource();
  if (corners.length === 4){
    picking = false;
    setOut("–£–≥–ª—ã –≤—ã–±—Ä–∞–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  updateUI();
});

runBtn.addEventListener("click", () => {
  if (!imgObj || corners.length !== 4) return;

  setOut("–†–∞—Å–ø—Ä–µ–º–ª–µ–Ω–∏–µ –∏ blob-–∞–Ω–∞–ª–∏–∑‚Ä¶", "warn");

  const warped = warpToRect(cSrc, corners, RECT, RECT);
  cRect.width = RECT; cRect.height = RECT;
  rectCtx.putImageData(warped, 0, 0);

  const s = parseInt(sens.value,10); // 1..20
  const result = detectBlobsDoG(warped, RECT, RECT, s);

  // draw
  rectCtx.putImageData(warped, 0, 0);
  rectCtx.lineWidth = 3;
  rectCtx.strokeStyle = "#00ff00";
  let sum=0;
  for(const p of result){
    sum += p.dMm;
    rectCtx.beginPath();
    rectCtx.arc(p.x, p.y, Math.max(6, p.r), 0, Math.PI*2);
    rectCtx.stroke();
  }
  const n = result.length;
  const avg = n ? (sum/n).toFixed(1) : "0.0";
  setOut(
    `–ü–∏–Ω—ã 4‚Äì12 –º–º (–≤ —Ä–æ—Å—Ç): ${n}\n–°—Ä–µ–¥–Ω–∏–π –¥–∏–∞–º–µ—Ç—Ä: ${avg} –º–º\nSensitivity: ${s}\n–ú–∞—Å—à—Ç–∞–±: ${mmPerPx.toFixed(4)} –º–º/px`,
    n ? "ok" : "bad"
  );
});

// ---------- image helpers ----------
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function drawSource(){
  const maxW = 1100;
  const sc = Math.min(1, maxW / imgObj.naturalWidth);
  const w = Math.round(imgObj.naturalWidth * sc);
  const h = Math.round(imgObj.naturalHeight * sc);
  cSrc.width = w; cSrc.height = h;
  srcCtx.drawImage(imgObj, 0, 0, w, h);

  if (corners.length){
    srcCtx.lineWidth = 4;
    srcCtx.strokeStyle = "#00ff00";
    srcCtx.fillStyle = "#00ff00";
    srcCtx.font = "20px system-ui";
    corners.forEach((p,i)=>{
      srcCtx.beginPath(); srcCtx.arc(p.x,p.y,8,0,Math.PI*2); srcCtx.fill();
      srcCtx.fillText(String(i+1), p.x+10, p.y-10);
    });
    if (corners.length===4){
      srcCtx.beginPath();
      srcCtx.moveTo(corners[0].x,corners[0].y);
      for(let i=1;i<4;i++) srcCtx.lineTo(corners[i].x,corners[i].y);
      srcCtx.closePath(); srcCtx.stroke();
    }
  }
}

// ---------- perspective warp ----------
function warpToRect(sourceCanvas, srcPts, dstW, dstH){
  const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
  const H = computeHomography(dstPts, srcPts);

  const sCtx = sourceCanvas.getContext("2d", { willReadFrequently:true });
  const sW = sourceCanvas.width, sH = sourceCanvas.height;
  const sData = sCtx.getImageData(0,0,sW,sH).data;

  const out = new ImageData(dstW, dstH);
  const o = out.data;

  for(let y=0;y<dstH;y++){
    for(let x=0;x<dstW;x++){
      const [sx, sy] = applyH(H, x, y);
      const ix = Math.floor(sx), iy = Math.floor(sy);
      const di = (y*dstW + x)*4;
      if (ix>=0 && iy>=0 && ix<sW && iy<sH){
        const si = (iy*sW + ix)*4;
        o[di]=sData[si]; o[di+1]=sData[si+1]; o[di+2]=sData[si+2]; o[di+3]=255;
      } else { o[di]=o[di+1]=o[di+2]=0; o[di+3]=255; }
    }
  }
  return out;
}
function applyH(H, x, y){
  const a = H[0]*x + H[1]*y + H[2];
  const b = H[3]*x + H[4]*y + H[5];
  const c = H[6]*x + H[7]*y + H[8];
  return [a/c, b/c];
}
function computeHomography(p, q){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const x=p[i].x, y=p[i].y, u=q[i].x, v=q[i].y;
    A.push([x,y,1,0,0,0,-x*u,-y*u]); b.push(u);
    A.push([0,0,0,x,y,1,-x*v,-y*v]); b.push(v);
  }
  const h = solve8(A,b);
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7],1];
}
function solve8(A,b){
  const n=8, M=A.map((r,i)=>r.concat([b[i]]));
  for(let c=0;c<n;c++){
    let p=c; for(let r=c+1;r<n;r++) if(Math.abs(M[r][c])>Math.abs(M[p][c])) p=r;
    [M[c],M[p]]=[M[p],M[c]];
    const d=M[c][c]||1e-12; for(let j=c;j<=n;j++) M[c][j]/=d;
    for(let r=0;r<n;r++){ if(r===c) continue; const f=M[r][c]; for(let j=c;j<=n;j++) M[r][j]-=f*M[c][j]; }
  }
  return M.map(r=>r[n]);
}

// ---------- DoG blob detection ----------
function detectBlobsDoG(imageData, w, h, sensitivity){
  // sensitivity: 1..20 -> threshold
  // lower sensitivity => higher threshold (stricter)
  const thr = 18 - sensitivity*0.7; // ~17.3 .. ~4
  const thr2 = Math.max(3, thr);

  // grayscale float
  const d = imageData.data;
  const g = new Float32Array(w*h);
  for(let i=0;i<w*h;i++){
    g[i] = 0.2126*d[i*4] + 0.7152*d[i*4+1] + 0.0722*d[i*4+2];
  }

  // normalize contrast a bit (remove slow background)
  const bg = boxBlur(g,w,h,18);
  for(let i=0;i<w*h;i++) g[i] = g[i] - bg[i]; // now local contrast

  // scales: radii from RMIN..RMAX
  // sigma ~ r / sqrt(2)
  const sigmas = [];
  for(let r=RMIN; r<=RMAX; r*=1.18){
    sigmas.push(r/1.4142);
  }

  // compute blurred images for each sigma
  const blurs = sigmas.map(s => gaussianBlurSep(g,w,h,s));

  // DoG responses
  const candidates = [];
  for(let k=0;k<blurs.length-1;k++){
    const a = blurs[k], b2 = blurs[k+1];
    const dog = new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i] = a[i] - b2[i];

    // local maxima (3x3) above threshold
    // Use k scale radius approx
    const r = sigmas[k]*1.4142;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const idx = y*w + x;
        const v = dog[idx];
        if(v < thr2) continue;
        // local max
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        candidates.push({x,y,score:v,r});
      }
    }
  }

  // sort by score desc and do non-maximum suppression in space
  candidates.sort((p,q)=>q.score-p.score);
  const kept = [];
  const minDist = 10; // px
  const minDist2 = minDist*minDist;

  for(const c of candidates){
    let ok = true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minDist2){
        ok=false; break;
      }
    }
    if(!ok) continue;

    // size filter in mm
    const dMm = (2*c.r) * mmPerPx;
    if(dMm < DMIN_MM || dMm > DMAX_MM) continue;

    kept.push({
      x:c.x, y:c.y,
      r: c.r,
      dMm
    });
    if(kept.length > 250) break; // safety
  }

  return kept;
}

// ---------- blurs ----------
function gaussianBlurSep(src,w,h,sigma){
  const r = Math.max(1, Math.ceil(sigma*2.5));
  const k = gaussianKernel1D(sigma, r);
  const tmp = new Float32Array(w*h);
  const dst = new Float32Array(w*h);

  // horizontal
  for(let y=0;y<h;y++){
    const row = y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx = Math.min(w-1, Math.max(0, x+i));
        sum += src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  // vertical
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy = Math.min(h-1, Math.max(0, y+i));
        sum += tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}
function gaussianKernel1D(sigma, r){
  const k = new Float32Array(2*r+1);
  const s2 = sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v = Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}
</script>
</body>
</html>
