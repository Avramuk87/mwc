<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî B (Semi-auto) + Training</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0;line-height:1.35}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:150px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#111;white-space:pre-wrap}
  .ok{color:#0a7;font-weight:800}
  .warn{color:#c90;font-weight:800}
  .bad{color:#c00;font-weight:800}
  .pill{display:inline-block;border:1px solid #ddd;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;font-size:12px}
</style>
</head>

<body>
<h1>MWC ‚Äî –í–∞—Ä–∏–∞–Ω—Ç B + –æ–±—É—á–µ–Ω–∏–µ</h1>
<div class="small">
<b>–®–∞–≥–∏:</b> 1) Day1 + Day2 ‚Üí 2) ¬´–ê–Ω–∞–ª–∏–∑¬ª ‚Üí 3) –≤–∫–ª—é—á–∏ ¬´–û–±—É—á–µ–Ω–∏–µ¬ª –∏ –ø–æ–º–µ—Ç—å 10‚Äì30 –∫—Ä—É–∂–∫–æ–≤ GOOD/BAD ‚Üí 4) ¬´–û–±—É—á–∏—Ç—å¬ª ‚Üí —Å–Ω–æ–≤–∞ ¬´–ê–Ω–∞–ª–∏–∑¬ª.<br>
–ù–∞ Day2: üü¢ grown, üîµ same, üü° new, ‚ö™ candidate, üî¥ excluded, üü† manual.
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <div class="small">Day1</div>
  <input id="img1" type="file" accept="image/*">
  <div class="small">Day2</div>
  <input id="img2" type="file" accept="image/*">

  <div class="row">
    <button id="show1" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day1</button>
    <button id="show2" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day2</button>
  </div>

  <button id="analyze" disabled>–ê–Ω–∞–ª–∏–∑</button>

  <div class="row">
    <button id="toggleTrain" class="secondary" disabled>–û–±—É—á–µ–Ω–∏–µ: OFF</button>
    <button id="train" class="secondary" disabled>–û–±—É—á–∏—Ç—å –ø–æ –º–µ—Ç–∫–∞–º</button>
  </div>

  <div class="row">
    <button id="saveModel" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–æ–¥–µ–ª—å</button>
    <button id="resetModel" class="secondary" disabled>–°–±—Ä–æ—Å–∏—Ç—å –º–æ–¥–µ–ª—å</button>
  </div>

  <div class="kv" id="out">–ó–∞–≥—Ä—É–∑–∏ –æ–±–∞ —Ñ–æ—Ç–æ.</div>

  <div class="small">
    <span class="pill">–û–±—É—á–µ–Ω–∏–µ: Tap = GOOD</span>
    <span class="pill">–û–±—É—á–µ–Ω–∏–µ: Tap –µ—â—ë —Ä–∞–∑ = BAD</span>
    <span class="pill">–û–±—É—á–µ–Ω–∏–µ: —Ç—Ä–µ—Ç–∏–π Tap = —Å–Ω—è—Ç—å –º–µ—Ç–∫—É</span>
  </div>
</div>

<div class="card">
  <b>–ü—Ä–æ—Å–º–æ—Ç—Ä</b>
  <canvas id="cv"></canvas>
  <div class="small" id="hint">
    –ü—Ä–∞–≤–∫–∏ (–Ω–µ –≤ –æ–±—É—á–µ–Ω–∏–∏): Tap=exclude ‚Ä¢ DoubleTap=add manual ‚Ä¢ Hold+Drag=move
  </div>

  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clearManual" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å manual</button>
    <button id="resetEdits" class="secondary" disabled>–°–±—Ä–æ—Å –ø—Ä–∞–≤–æ–∫</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>

  <div class="small kv">
üü¢ grown ‚Ä¢ üîµ same ‚Ä¢ üü° new ‚Ä¢ ‚ö™ candidate ‚Ä¢ üî¥ excluded ‚Ä¢ üü† manual ‚Ä¢ üü£ GOOD label ‚Ä¢ üü• BAD label
  </div>
</div>

<script>
/* =======================
   –ë–ê–ó–û–í–´–ï –ü–ê–†–ê–ú–ï–¢–†–´
   (–ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è –æ–Ω–∏ –±—É–¥—É—Ç –∞–≤—Ç–æ-–æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è)
======================= */
const WORK_MAX_W = 900;

let MODEL = loadModel() || {
  dogThr: 9.0,
  nmsMinDist: 12,
  minR: 8,
  maxR: 120,

  // –∫—Ä—É–≥–ª—ã–π —Ñ–∏–ª—å—Ç—Ä Day2
  day2: { edgeMeanMin: 11, edgeCVMax: 0.70, contrastMin: 8 },

  // –∫—Ä—É–≥–ª—ã–π —Ñ–∏–ª—å—Ç—Ä Day1
  day1: { edgeMeanMin: 10, edgeCVMax: 0.80, contrastMin: 6 },

  growPx: 1.6,
  matchMaxDist: 18
};

/* ======= UI ======= */
const img1Input = document.getElementById("img1");
const img2Input = document.getElementById("img2");
const show1Btn = document.getElementById("show1");
const show2Btn = document.getElementById("show2");
const analyzeBtn = document.getElementById("analyze");
const toggleTrainBtn = document.getElementById("toggleTrain");
const trainBtn = document.getElementById("train");
const saveModelBtn = document.getElementById("saveModel");
const resetModelBtn = document.getElementById("resetModel");

const outEl = document.getElementById("out");
const hintEl = document.getElementById("hint");

const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { willReadFrequently:true });

const undoBtn = document.getElementById("undo");
const clearManualBtn = document.getElementById("clearManual");
const resetEditsBtn = document.getElementById("resetEdits");
const exportBtn = document.getElementById("export");
const saveBtn = document.getElementById("savepng");

let day1=null, day2=null;
let view=2;

let trainingMode=false;

/*
work = {
  W,H, dx,dy, score,
  g2, g1a (lazy),
  blobs2: [{
    x,y,r, src:"auto|manual",
    excluded:false,
    cls:"grown|same|new|candidate",
    match:{found,r1},
    feat:{edgeMean, edgeCV, contrast},
    label: 0|1|2   // 0 none, 1 good, 2 bad (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è)
  }],
  baseBlobs2: [...]
}
*/
let work=null;
let history=[];

let dragging=false, dragIdx=-1;
let pressTimer=null;
let lastTapTime=0, lastTapPos=null;

function setOut(t, cls=""){
  outEl.className = "kv " + cls;
  outEl.textContent = t;
}
function ready(){ return !!(day1 && day2); }
function updateUI(){
  const r = ready();
  show1Btn.disabled = !r;
  show2Btn.disabled = !r;
  analyzeBtn.disabled = !r;

  toggleTrainBtn.disabled = !work;
  trainBtn.disabled = !work;
  saveModelBtn.disabled = !work;
  resetModelBtn.disabled = false;

  undoBtn.disabled = history.length===0;
  clearManualBtn.disabled = !(work && work.blobs2.some(b=>b.src==="manual"));
  resetEditsBtn.disabled = !(work && work.baseBlobs2 && work.baseBlobs2.length);

  exportBtn.disabled = !work;
  saveBtn.disabled = !ready();

  hintEl.textContent = trainingMode
    ? "–û–±—É—á–µ–Ω–∏–µ: Tap –ø–æ –∫—Ä—É–∂–∫—É —Ü–∏–∫–ª–æ–º GOOD ‚Üí BAD ‚Üí —Å–Ω—è—Ç–æ. –ó–∞—Ç–µ–º ¬´–û–±—É—á–∏—Ç—å¬ª."
    : "–ü—Ä–∞–≤–∫–∏ (–Ω–µ –≤ –æ–±—É—á–µ–Ω–∏–∏): Tap=exclude ‚Ä¢ DoubleTap=add manual ‚Ä¢ Hold+Drag=move";
}
function pushHistory(){
  if(!work) return;
  history.push(JSON.stringify(work.blobs2));
  if(history.length>120) history.shift();
  updateUI();
}

function fileToImg(f){
  return new Promise((resolve,reject)=>{
    const i=new Image();
    i.onload=()=>resolve(i);
    i.onerror=reject;
    i.src=URL.createObjectURL(f);
  });
}
function fitCanvasToImage(img){
  const maxW=1100;
  const sc=Math.min(1, maxW / img.naturalWidth);
  cv.width=Math.round(img.naturalWidth*sc);
  cv.height=Math.round(img.naturalHeight*sc);
}
function drawBaseImage(){
  if(!ready()) return;
  if(view===1){
    fitCanvasToImage(day1);
    ctx.drawImage(day1,0,0,cv.width,cv.height);
  }else{
    fitCanvasToImage(day2);
    ctx.drawImage(day2,0,0,cv.width,cv.height);
  }
}
function canvasXY(ev){
  const r=cv.getBoundingClientRect();
  const x=(ev.clientX - r.left) * (cv.width / r.width);
  const y=(ev.clientY - r.top)  * (cv.height/ r.height);
  return {x,y};
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function colorForBlob(b){
  if(b.excluded) return "#ff3333"; // red
  if(b.label===1) return "#a855f7"; // purple GOOD label
  if(b.label===2) return "#ff0066"; // magenta BAD label
  if(b.src==="manual") return "#ff9900"; // orange
  if(b.cls==="grown") return "#00aa55"; // green
  if(b.cls==="new") return "#ffd400"; // yellow
  if(b.cls==="same") return "#2aa8ff"; // blue
  return "#ffffff"; // candidate
}

function redraw(){
  if(!ready()) return;
  drawBaseImage();

  if(view===2 && work){
    const sx=cv.width/work.W;
    const sy=cv.height/work.H;

    ctx.lineWidth=3;
    for(const b of work.blobs2){
      const x=b.x*sx, y=b.y*sy;
      const r=Math.max(8, b.r*sx);
      ctx.strokeStyle = colorForBlob(b);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
    }

    const all = work.blobs2.filter(b=>!b.excluded).length;
    const grown = work.blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
    const news  = work.blobs2.filter(b=>!b.excluded && b.cls==="new").length;
    const goodL = work.blobs2.filter(b=>b.label===1).length;
    const badL  = work.blobs2.filter(b=>b.label===2).length;

    ctx.font="14px ui-monospace, Menlo, monospace";
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(8,8,560,72);
    ctx.fillStyle="#fff";
    ctx.fillText(`all: ${all}  grown: ${grown}  new: ${news}`, 14, 28);
    ctx.fillText(`labels good: ${goodL}  bad: ${badL}  training: ${trainingMode?"ON":"OFF"}`, 14, 46);
    ctx.fillText(`model: minR=${MODEL.minR} dogThr=${MODEL.dogThr} growPx=${MODEL.growPx}`, 14, 64);
  }

  updateUI();
}

/* =======================
   IMAGE PROCESSING
======================= */
function toGray(rgba,n){
  const g=new Float32Array(n);
  for(let i=0;i<n;i++){
    const r=rgba[i*4], gg=rgba[i*4+1], b=rgba[i*4+2];
    g[i]=0.2126*r + 0.7152*gg + 0.0722*b;
  }
  return g;
}
function gaussianKernel1D(sigma,r){
  const k=new Float32Array(2*r+1);
  const s2=sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v=Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function gaussianBlurSep(src,w,h,sigma){
  const r=Math.max(1, Math.ceil(sigma*2.5));
  const k=gaussianKernel1D(sigma,r);
  const tmp=new Float32Array(w*h);
  const dst=new Float32Array(w*h);

  for(let y=0;y<h;y++){
    const row=y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx=Math.min(w-1,Math.max(0,x+i));
        sum+=src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy=Math.min(h-1,Math.max(0,y+i));
        sum+=tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

function detectBlobsDoG(g,w,h){
  const bg=boxBlur(g,w,h,18);
  const x=new Float32Array(w*h);
  for(let i=0;i<w*h;i++) x[i]=g[i]-bg[i];

  const rMin=Math.max(MODEL.minR, 6);
  const rMax=Math.min(90, Math.min(w,h)*0.16);

  const sigmas=[];
  for(let r=rMin; r<=rMax; r*=1.22){
    sigmas.push(r/1.4142);
    if(sigmas.length>18) break;
  }
  const blurs=sigmas.map(s=>gaussianBlurSep(x,w,h,s));

  const cand=[];
  for(let k=0;k<blurs.length-1;k++){
    const a=blurs[k], b=blurs[k+1];
    const dog=new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i]=a[i]-b[i];
    const r=sigmas[k]*1.4142;

    for(let y=1;y<h-1;y++){
      for(let x2=1;x2<w-1;x2++){
        const idx=y*w+x2;
        const v=dog[idx];
        if(v < MODEL.dogThr) continue;
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        cand.push({x:x2,y,score:v,r});
      }
    }
  }

  cand.sort((p,q)=>q.score-p.score);
  const kept=[];
  const minD2=MODEL.nmsMinDist*MODEL.nmsMinDist;

  for(const c of cand){
    if(c.r < MODEL.minR || c.r > MODEL.maxR) continue;
    let ok=true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minD2){ ok=false; break; }
    }
    if(!ok) continue;
    kept.push({x:c.x,y:c.y,r:c.r,score:c.score});
    if(kept.length>500) break;
  }
  return kept;
}

/* ---- shift estimation (translation) ---- */
function resizeGrayNearest(src,SW,SH,W,H){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy=Math.min(SH-1,Math.max(0,Math.round(y*SH/H)));
    for(let x=0;x<W;x++){
      const sx=Math.min(SW-1,Math.max(0,Math.round(x*SW/W)));
      dst[y*W+x]=src[sy*SW+sx];
    }
  }
  return dst;
}
function gradMag(g,W,H){
  const out=new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i=y*W+x;
      const gx=g[i+1]-g[i-1];
      const gy=g[i+W]-g[i-W];
      out[i]=Math.abs(gx)+Math.abs(gy);
    }
  }
  return out;
}
function estimateShift(g1,g2,W,H){
  const max=260;
  const sc=Math.min(1, max / W);
  const w=Math.max(90,Math.round(W*sc));
  const h=Math.max(90,Math.round(H*sc));

  const a=resizeGrayNearest(g1,W,H,w,h);
  const b=resizeGrayNearest(g2,W,H,w,h);
  const ag=gradMag(a,w,h);
  const bg=gradMag(b,w,h);

  const range=24;
  const x0=Math.floor(w*0.15), x1=Math.floor(w*0.85);
  const y0=Math.floor(h*0.15), y1=Math.floor(h*0.85);

  let best={dx:0,dy:0,score:Infinity};
  for(let dy=-range; dy<=range; dy++){
    for(let dx=-range; dx<=range; dx++){
      let s=0, cnt=0;
      for(let y=y0; y<y1; y++){
        const sy=y-dy;
        if(sy<y0||sy>=y1) continue;
        const row=y*w, srow=sy*w;
        for(let x=x0; x<x1; x++){
          const sx=x-dx;
          if(sx<x0||sx>=x1) continue;
          s+=Math.abs(bg[row+x]-ag[srow+sx]);
          cnt++;
        }
      }
      if(cnt){
        const score=s/cnt;
        if(score<best.score) best={dx,dy,score};
      }
    }
  }
  return {dx:Math.round(best.dx/sc), dy:Math.round(best.dy/sc), score:best.score};
}
function shiftGray(src,W,H,dx,dy){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy=y-dy;
    if(sy<0||sy>=H) continue;
    for(let x=0;x<W;x++){
      const sx=x-dx;
      if(sx<0||sx>=W) continue;
      dst[y*W+x]=src[sy*W+sx];
    }
  }
  return dst;
}

/* ---- radius + circularity ---- */
function estimateRadiusAt(gray,W,H,cx,cy,rMin,rMax){
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return null;

  const N=24;
  let bestR=null, bestS=0;

  for(let r=rMin; r<=rMax; r+=2){
    let s=0, cnt=0;
    for(let k=0;k<N;k++){
      const ang=(k/N)*Math.PI*2;
      const x=x0+Math.cos(ang)*r;
      const y=y0+Math.sin(ang)*r;
      const ix=Math.round(x), iy=Math.round(y);
      if(ix<1||iy<1||ix>=W-1||iy>=H-1) continue;
      const i=iy*W+ix;
      const gx=gray[i+1]-gray[i-1];
      const gy=gray[i+W]-gray[i-W];
      s += Math.abs(gx)+Math.abs(gy);
      cnt++;
    }
    if(cnt){
      const avg=s/cnt;
      if(avg>bestS){ bestS=avg; bestR=r; }
    }
  }
  if(bestR===null) return null;
  if(bestS < 10) return null; // –±–∞–∑–æ–≤—ã–π –ø–æ—Ä–æ–≥, –¥–∞–ª—å—à–µ –æ–±—É—á–µ–Ω–∏–µ–º —Å—Ç–∞–Ω–µ—Ç –ª—É—á—à–µ
  return bestR;
}

function circleQuality(gray,W,H,cx,cy,r){
  const N=24;
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return {ok:false};

  const rin=Math.max(2, Math.round(r*0.70));
  const rout=Math.max(r+2, Math.round(r*1.15));

  let edgeSum=0, edgeSum2=0, edgeCnt=0;
  let inSum=0,inCnt=0;
  let outSum=0,outCnt=0;

  for(let k=0;k<N;k++){
    const ang=(k/N)*Math.PI*2;
    const cs=Math.cos(ang), sn=Math.sin(ang);

    const ixE=Math.round(x0+cs*r);
    const iyE=Math.round(y0+sn*r);
    if(ixE<1||iyE<1||ixE>=W-1||iyE>=H-1) continue;
    const iE=iyE*W+ixE;
    const gx=gray[iE+1]-gray[iE-1];
    const gy=gray[iE+W]-gray[iE-W];
    const e=Math.abs(gx)+Math.abs(gy);
    edgeSum+=e; edgeSum2+=e*e; edgeCnt++;

    const ixI=Math.round(x0+cs*rin);
    const iyI=Math.round(y0+sn*rin);
    if(ixI>=0&&iyI>=0&&ixI<W&&iyI<H){ inSum+=gray[iyI*W+ixI]; inCnt++; }

    const ixO=Math.round(x0+cs*rout);
    const iyO=Math.round(y0+sn*rout);
    if(ixO>=0&&iyO>=0&&ixO<W&&iyO<H){ outSum+=gray[iyO*W+ixO]; outCnt++; }
  }

  if(edgeCnt<12 || inCnt<12 || outCnt<12) return {ok:false};

  const edgeMean=edgeSum/edgeCnt;
  const edgeStd=Math.sqrt(Math.max(1e-6, edgeSum2/edgeCnt - edgeMean*edgeMean));
  const edgeCV=edgeStd/Math.max(1e-6, edgeMean);
  const contrast=(inSum/inCnt) - (outSum/outCnt);

  return {ok:true, edgeMean, edgeCV, contrast};
}

function passCirc(q, thr){
  if(!q.ok) return false;
  if(q.edgeMean < thr.edgeMeanMin) return false;
  if(q.edgeCV > thr.edgeCVMax) return false;
  if(q.contrast < thr.contrastMin) return false;
  return true;
}

/* =======================
   ANALYZE
======================= */
async function runAnalyze(){
  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶","warn");

  const sc=Math.min(1, WORK_MAX_W / day2.naturalWidth);
  const W=Math.round(day2.naturalWidth*sc);
  const H=Math.round(day2.naturalHeight*sc);

  const c1=document.createElement("canvas");
  const c2=document.createElement("canvas");
  c1.width=W; c1.height=H;
  c2.width=W; c2.height=H;
  const x1=c1.getContext("2d",{willReadFrequently:true});
  const x2=c2.getContext("2d",{willReadFrequently:true});
  x1.drawImage(day1,0,0,W,H);
  x2.drawImage(day2,0,0,W,H);

  const im1=x1.getImageData(0,0,W,H);
  const im2=x2.getImageData(0,0,W,H);
  const g1=toGray(im1.data,W*H);
  const g2=toGray(im2.data,W*H);

  setOut("–ê–Ω–∞–ª–∏–∑: –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ Day1 ‚Üí Day2‚Ä¶","warn");
  const {dx,dy,score}=estimateShift(g1,g2,W,H);
  const g1a=shiftGray(g1,W,H,dx,dy);

  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–∏—Å–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞ Day2‚Ä¶","warn");
  const raw2=detectBlobsDoG(g2,W,H);

  const blobs2=[];
  let rejected=0;

  for(const b of raw2){
    const r2=estimateRadiusAt(g2,W,H,b.x,b.y, MODEL.minR, MODEL.maxR);
    if(r2===null){ rejected++; continue; }
    if(r2<MODEL.minR || r2>MODEL.maxR){ rejected++; continue; }

    const q2=circleQuality(g2,W,H,b.x,b.y,r2);
    const feat={edgeMean:q2.edgeMean||0, edgeCV:q2.edgeCV||999, contrast:q2.contrast||-999};

    // –í–∞–∂–Ω–æ: –¥–æ –æ–±—É—á–µ–Ω–∏—è –º–æ–∂–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤, –¥–∞–∂–µ –µ—Å–ª–∏ —Ñ–∏–ª—å—Ç—Ä –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç
    // –ù–æ –µ—Å–ª–∏ –º–æ–¥–µ–ª—å —É–∂–µ –æ–±—É—á–µ–Ω–∞ ‚Äî –ø—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –∂—ë—Å—Ç–∫–æ
    const trained = !!MODEL._trained;
    if(trained && !passCirc(q2, MODEL.day2)){ rejected++; continue; }

    blobs2.push({
      x:b.x,y:b.y,r:r2,
      src:"auto",
      excluded:false,
      cls: trained ? "candidate" : "candidate",
      match:{found:false,r1:null},
      feat,
      label: 0
    });
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—Ç–∫–∏, –µ—Å–ª–∏ work —É–∂–µ –±—ã–ª (—á—Ç–æ–±—ã –ø–æ—Å–ª–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –º–µ—Ç–∫–∏ –Ω–µ —Å–ª–µ—Ç–∞–ª–∏)
  if(work && work.blobs2){
    // –≥—Ä—É–±–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç–æ–∫ –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏ —Ü–µ–Ω—Ç—Ä–∞
    for(const nb of blobs2){
      let best=null, bestD=1e18;
      for(const ob of work.blobs2){
        const dx=nb.x-ob.x, dy=nb.y-ob.y;
        const d=dx*dx+dy*dy;
        if(d<bestD && d < 18*18){ bestD=d; best=ob; }
      }
      if(best) nb.label = best.label || 0;
    }
  }

  // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤
  setOut("–ê–Ω–∞–ª–∏–∑: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ (—Ä–æ—Å—Ç)‚Ä¶","warn");
  for(const b of blobs2){
    let best=null;

    for(let oy=-MODEL.matchMaxDist; oy<=MODEL.matchMaxDist; oy+=3){
      for(let ox=-MODEL.matchMaxDist; ox<=MODEL.matchMaxDist; ox+=3){
        const cx=b.x+ox, cy=b.y+oy;
        if(cx<2||cy<2||cx>=W-2||cy>=H-2) continue;

        const r1=estimateRadiusAt(g1a,W,H,cx,cy, MODEL.minR, MODEL.maxR);
        if(r1===null) continue;

        const q1=circleQuality(g1a,W,H,cx,cy,r1);
        if(MODEL._trained && !passCirc(q1, MODEL.day1)) continue; // —Ç—Ä–µ–±—É–µ–º ‚Äú–≥—Ä–∏–±–Ω–æ—Å—Ç—å‚Äù –Ω–∞ Day1

        const d2=ox*ox+oy*oy;
        const clos = 1/(1+Math.abs(r1-b.r));
        const scv = clos / (1 + d2*0.02);

        if(!best || scv>best.score) best={r1, score:scv};
      }
    }

    if(!best){
      b.cls="new";
      b.match={found:false,r1:null};
    }else{
      b.match={found:true,r1:best.r1};
      b.cls = (b.r - best.r1) >= MODEL.growPx ? "grown" : "same";
    }
  }

  work = {
    W,H, dx,dy, score,
    _g2: g2,
    _g1a: g1a,
    blobs2,
    baseBlobs2: JSON.parse(JSON.stringify(blobs2)),
    meta:{kept:blobs2.length, rejected}
  };
  history=[];
  view=2;

  const all=blobs2.filter(b=>!b.excluded).length;
  const grown=blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
  const news=blobs2.filter(b=>!b.excluded && b.cls==="new").length;

  setOut(
`–ì–æ—Ç–æ–≤–æ.
–°–¥–≤–∏–≥: dx=${dx}, dy=${dy} (score=${score.toFixed(1)})
–ù–∞–π–¥–µ–Ω–æ (Day2): ${all}   –í—ã—Ä–æ—Å–ª–æ: ${grown}   –ù–æ–≤—ã–µ: ${news}
–û—Ç–±—Ä–∞–∫–æ–≤–∞–Ω–æ: ${rejected}
–ú–æ–¥–µ–ª—å: minR=${MODEL.minR}, dogThr=${MODEL.dogThr}, growPx=${MODEL.growPx}
–û–±—É—á–µ–Ω–∞: ${MODEL._trained ? "–î–ê" : "–ù–ï–¢"}`, "ok");

  redraw();
}

/* =======================
   TRAINING
   –¢—ã —Å—Ç–∞–≤–∏—à—å –º–µ—Ç–∫–∏ GOOD/BAD –Ω–∞ –∫—Ä—É–∂–∫–∞—Ö Day2.
   –ú—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–±–∏—Ä–∞–µ–º –ø–æ—Ä–æ–≥–∏:
   - minR
   - day2 edgeMean/edgeCV/contrast
   - dogThr –Ω–µ —Ç—Ä–æ–≥–∞–µ–º –∂—ë—Å—Ç–∫–æ (–æ—Å—Ç–∞–≤–ª—è–µ–º), –Ω–æ –º–æ–∂–Ω–æ –Ω–µ–º–Ω–æ–≥–æ –ø–æ–¥—Ç—è–Ω—É—Ç—å
======================= */
function percentile(arr, p){
  if(!arr.length) return null;
  const a=[...arr].sort((x,y)=>x-y);
  const idx = Math.min(a.length-1, Math.max(0, Math.round((p/100)*(a.length-1))));
  return a[idx];
}
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function trainFromLabels(){
  if(!work) return;

  const good = work.blobs2.filter(b=>b.label===1 && !b.excluded);
  const bad  = work.blobs2.filter(b=>b.label===2 && !b.excluded);

  if(good.length < 6 || bad.length < 6){
    setOut(`–î–ª—è –æ–±—É—á–µ–Ω–∏—è –Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º ~6 GOOD –∏ ~6 BAD. –°–µ–π—á–∞—Å GOOD=${good.length}, BAD=${bad.length}.`, "warn");
    return;
  }

  // –±–µ—Ä—ë–º –ø—Ä–∏–∑–Ω–∞–∫–∏
  const g_edgeMean = good.map(b=>b.feat.edgeMean);
  const g_edgeCV   = good.map(b=>b.feat.edgeCV);
  const g_contrast = good.map(b=>b.feat.contrast);
  const g_r        = good.map(b=>b.r);

  const b_edgeMean = bad.map(b=>b.feat.edgeMean);
  const b_edgeCV   = bad.map(b=>b.feat.edgeCV);
  const b_contrast = bad.map(b=>b.feat.contrast);
  const b_r        = bad.map(b=>b.r);

  // –õ–û–ì–ò–ö–ê –ü–û–†–û–ì–û–í:
  // - edgeMeanMin: —á—É—Ç—å –Ω–∏–∂–µ ‚Äú—Å–ª–∞–±—ã—Ö‚Äù good, –Ω–æ –≤—ã—à–µ –±–æ–ª—å—à–µ–π —á–∞—Å—Ç–∏ bad
  // - edgeCVMax: —á—É—Ç—å –≤—ã—à–µ ‚Äú–ø–ª–æ—Ö–∏—Ö‚Äù good, –Ω–æ –Ω–∏–∂–µ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ bad
  // - contrastMin: —á—É—Ç—å –Ω–∏–∂–µ —Å–ª–∞–±—ã—Ö good, –Ω–æ –≤—ã—à–µ bad

  const edgeMeanMin = clamp(
    Math.max( percentile(g_edgeMean, 15) - 1.0, percentile(b_edgeMean, 70) ),
    6, 30
  );
  const edgeCVMax = clamp(
    Math.min( percentile(g_edgeCV, 85) + 0.05, percentile(b_edgeCV, 30) ),
    0.30, 0.95
  );
  const contrastMin = clamp(
    Math.max( percentile(g_contrast, 15) - 1.0, percentile(b_contrast, 70) ),
    2, 30
  );

  // minR: –±–µ—Ä—ë–º –Ω–∏–∂–Ω–∏–π —Ö–≤–æ—Å—Ç good (—á—Ç–æ–±—ã –º–∏—Ü–µ–ª–∏–π –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏–ª)
  const minR = clamp( Math.round(percentile(g_r, 10)), 6, 20 );

  // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –º–æ–¥–µ–ª—å
  MODEL.day2 = { edgeMeanMin, edgeCVMax, contrastMin };

  // Day1 –¥–µ–ª–∞–µ–º —á—É—Ç—å –º—è–≥—á–µ, —á—Ç–æ–±—ã ‚Äú—Å—Ç–∞—Ä—ã–µ –≥—Ä–∏–±—ã‚Äù —á–∞—â–µ –Ω–∞—Ö–æ–¥–∏–ª–∏—Å—å
  MODEL.day1 = {
    edgeMeanMin: clamp(edgeMeanMin - 1.0, 5, 25),
    edgeCVMax:   clamp(edgeCVMax + 0.10, 0.35, 0.98),
    contrastMin: clamp(contrastMin - 2.0, 1, 25)
  };

  MODEL.minR = minR;
  MODEL._trained = true;

  // –ø–æ–¥—Å–∫–∞–∑–∫–∞: dogThr –º–æ–∂–Ω–æ —Å–ª–µ–≥–∫–∞ –ø–æ–¥–Ω—è—Ç—å, –µ—Å–ª–∏ bad —Å–∏–ª—å–Ω–æ –±–æ–ª—å—à–µ good
  // –Ω–æ –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –µ—Å—Ç—å (—Å—Ç–∞–±–∏–ª—å–Ω–µ–µ). –ü—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å.

  saveModel(MODEL);

  setOut(
`–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ ‚úÖ
GOOD=${good.length}, BAD=${bad.length}
–ù–æ–≤—ã–µ –ø–æ—Ä–æ–≥–∏ (Day2):
  edgeMeanMin=${MODEL.day2.edgeMeanMin.toFixed(1)}
  edgeCVMax=${MODEL.day2.edgeCVMax.toFixed(2)}
  contrastMin=${MODEL.day2.contrastMin.toFixed(1)}
minR=${MODEL.minR}
–°–æ—Ö—Ä–∞–Ω–∏–ª –º–æ–¥–µ–ª—å. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª –µ—â—ë —Ä–∞–∑.`, "ok");
}

/* =======================
   EDITING / LABELING
======================= */
function nearestBlobIdx(x,y,px=26){
  if(!work || view!==2) return -1;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const wx=x*sx, wy=y*sy;
  const p={x:wx,y:wy};
  const max2=(px*sx)*(px*sx);

  let best=-1, bestD=1e18;
  for(let i=0;i<work.blobs2.length;i++){
    const b=work.blobs2[i];
    const dx=b.x-p.x, dy=b.y-p.y;
    const d=dx*dx+dy*dy;
    if(d<max2 && d<bestD){ bestD=d; best=i; }
  }
  return best;
}

function cycleLabelAt(x,y){
  const idx=nearestBlobIdx(x,y,28);
  if(idx<0) return;
  pushHistory();
  const b=work.blobs2[idx];
  // 0 -> 1 -> 2 -> 0
  b.label = (b.label===0) ? 1 : (b.label===1 ? 2 : 0);
  redraw();
}

function toggleExcludeAt(x,y){
  const idx=nearestBlobIdx(x,y,28);
  if(idx<0) return;
  pushHistory();
  work.blobs2[idx].excluded = !work.blobs2[idx].excluded;
  redraw();
}

function addManualAt(x,y){
  if(!work) return;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const wx=x*sx, wy=y*sy;

  pushHistory();

  const g2=work._g2, g1a=work._g1a;
  let r=estimateRadiusAt(g2,work.W,work.H,wx,wy, MODEL.minR, MODEL.maxR);
  if(r===null) r=Math.max(18, MODEL.minR);

  const q2=circleQuality(g2,work.W,work.H,wx,wy,r);
  const feat={edgeMean:q2.edgeMean||0, edgeCV:q2.edgeCV||999, contrast:q2.contrast||-999};

  const b={x:wx,y:wy,r, src:"manual", excluded:false, cls:"candidate", match:{found:false,r1:null}, feat, label:0};

  const r1=estimateRadiusAt(g1a,work.W,work.H,wx,wy, MODEL.minR, MODEL.maxR);
  if(r1!==null){
    const q1=circleQuality(g1a,work.W,work.H,wx,wy,r1);
    if(!MODEL._trained || passCirc(q1, MODEL.day1)){
      b.match={found:true,r1};
      b.cls=(r-r1)>=MODEL.growPx ? "grown" : "same";
    } else {
      b.cls="new";
    }
  } else {
    b.cls="new";
  }

  work.blobs2.push(b);
  redraw();
}

function startDragAt(x,y){
  if(trainingMode) return false;
  const idx=nearestBlobIdx(x,y,32);
  if(idx<0) return false;
  pushHistory();
  dragging=true; dragIdx=idx;
  work.blobs2[idx].src="manual";
  return true;
}
function moveDragTo(x,y){
  if(!dragging||dragIdx<0) return;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const b=work.blobs2[dragIdx];
  b.x=x*sx; b.y=y*sy;
  redraw();
}
function endDrag(){ dragging=false; dragIdx=-1; }

/* =======================
   STORAGE (MODEL)
======================= */
function saveModel(m){
  try{ localStorage.setItem("MWC_MODEL_V1", JSON.stringify(m)); }catch(e){}
}
function loadModel(){
  try{
    const s=localStorage.getItem("MWC_MODEL_V1");
    return s ? JSON.parse(s) : null;
  }catch(e){ return null; }
}

/* =======================
   UI HANDLERS
======================= */
img1Input.addEventListener("change", async ()=>{
  work=null; history=[]; trainingMode=false;
  try{ day1=await fileToImg(img1Input.files[0]); setOut("Day1 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day2.","warn"); }
  catch(e){ day1=null; setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day1.","bad"); }
  if(ready()){ view=2; setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.","ok"); }
  redraw(); updateUI();
});
img2Input.addEventListener("change", async ()=>{
  work=null; history=[]; trainingMode=false;
  try{ day2=await fileToImg(img2Input.files[0]); setOut("Day2 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day1.","warn"); }
  catch(e){ day2=null; setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day2.","bad"); }
  if(ready()){ view=2; setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.","ok"); }
  redraw(); updateUI();
});

show1Btn.addEventListener("click", ()=>{ view=1; redraw(); });
show2Btn.addEventListener("click", ()=>{ view=2; redraw(); });

analyzeBtn.addEventListener("click", async ()=>{
  if(!ready()) return;
  await runAnalyze();
});

toggleTrainBtn.addEventListener("click", ()=>{
  if(!work) return;
  trainingMode = !trainingMode;
  toggleTrainBtn.textContent = `–û–±—É—á–µ–Ω–∏–µ: ${trainingMode ? "ON" : "OFF"}`;
  redraw();
});

trainBtn.addEventListener("click", ()=>{
  trainFromLabels();
});

saveModelBtn.addEventListener("click", ()=>{
  saveModel(MODEL);
  setOut("–ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ ‚úÖ (localStorage).", "ok");
});

resetModelBtn.addEventListener("click", ()=>{
  MODEL = {
    dogThr: 9.0, nmsMinDist: 12, minR: 8, maxR: 120,
    day2:{edgeMeanMin:11, edgeCVMax:0.70, contrastMin:8},
    day1:{edgeMeanMin:10, edgeCVMax:0.80, contrastMin:6},
    growPx:1.6, matchMaxDist:18
  };
  try{ localStorage.removeItem("MWC_MODEL_V1"); }catch(e){}
  setOut("–ú–æ–¥–µ–ª—å —Å–±—Ä–æ—à–µ–Ω–∞. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "warn");
  redraw();
});

undoBtn.addEventListener("click", ()=>{
  if(!history.length||!work) return;
  work.blobs2=JSON.parse(history.pop());
  redraw();
});
clearManualBtn.addEventListener("click", ()=>{
  if(!work) return;
  pushHistory();
  work.blobs2=work.blobs2.filter(b=>b.src!=="manual");
  redraw();
});
resetEditsBtn.addEventListener("click", ()=>{
  if(!work) return;
  history=[];
  work.blobs2=JSON.parse(JSON.stringify(work.baseBlobs2));
  redraw();
});

exportBtn.addEventListener("click", ()=>{
  if(!work) return;
  const payload={
    version:"MWC_B_TRAINING_V1",
    created_at:new Date().toISOString(),
    model: MODEL,
    align:{dx:work.dx,dy:work.dy,score:work.score},
    work_size:{W:work.W,H:work.H},
    blobs_day2:work.blobs2
  };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="mwc_training_export.json";
  a.click();
});
saveBtn.addEventListener("click", ()=>{
  if(!ready()) return;
  redraw();
  const a=document.createElement("a");
  a.href=cv.toDataURL("image/png");
  a.download = view===2 ? "mwc_day2_marked.png" : "mwc_day1.png";
  a.click();
});

/* ===== gestures ===== */
cv.addEventListener("mousedown",(ev)=>{
  if(!work||view!==2) return;
  const p=canvasXY(ev);
  pressTimer=setTimeout(()=> startDragAt(p.x,p.y), 180);
});
cv.addEventListener("mousemove",(ev)=>{
  if(!work||view!==2||!dragging) return;
  const p=canvasXY(ev);
  moveDragTo(p.x,p.y);
});
cv.addEventListener("mouseup",(ev)=>{
  if(!work||view!==2) return;
  clearTimeout(pressTimer);
  const p=canvasXY(ev);

  if(dragging){ endDrag(); return; }

  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(trainingMode){
    if(isDouble) return;
    cycleLabelAt(p.x,p.y);
  }else{
    if(isDouble) addManualAt(p.x,p.y);
    else toggleExcludeAt(p.x,p.y);
  }
});

cv.addEventListener("touchstart",(ev)=>{
  if(!work||view!==2) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);

  if(!trainingMode){
    pressTimer=setTimeout(()=> startDragAt(p.x,p.y), 180);
  }

  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(trainingMode){
    if(isDouble) return;
    cycleLabelAt(p.x,p.y);
  }else{
    if(isDouble){
      clearTimeout(pressTimer);
      addManualAt(p.x,p.y);
    }
  }
},{passive:false});

cv.addEventListener("touchmove",(ev)=>{
  if(!work||view!==2||!dragging) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);
  moveDragTo(p.x,p.y);
},{passive:false});

cv.addEventListener("touchend",(ev)=>{
  if(!work||view!==2) return;
  ev.preventDefault();
  clearTimeout(pressTimer);
  if(dragging){ endDrag(); return; }

  if(trainingMode) return;

  const t=ev.changedTouches[0];
  const p=canvasXY(t);
  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  if(!isDouble) toggleExcludeAt(p.x,p.y);
},{passive:false});

updateUI();
setOut(`–ì–æ—Ç–æ–≤–æ. –¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: minR=${MODEL.minR}, dogThr=${MODEL.dogThr}, growPx=${MODEL.growPx}.`, "ok");
</script>
</body>
</html>
