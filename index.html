<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî B2: Day1/Day2 Growth (Semi-auto, circularity)</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:150px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#111;white-space:pre-wrap}
  .ok{color:#0a7;font-weight:800}
  .warn{color:#c90;font-weight:800}
  .bad{color:#c00;font-weight:800}
</style>
</head>

<body>
<h1>MWC ‚Äî B2 (–ø–æ–ª—É–∞–≤—Ç–æ): –≤—ã—Ä–æ—Å—à–∏–µ –≥—Ä–∏–±—ã –∑–µ–ª—ë–Ω—ã–º</h1>
<div class="small">
1) –ó–∞–≥—Ä—É–∑–∏ Day1 + Day2 ‚Üí 2) ¬´–ê–Ω–∞–ª–∏–∑¬ª ‚Üí –Ω–∞ Day2: üü¢ grown, üü° new, ‚ö™ same, üî¥ excluded, üü† manual.<br>
–§–∏–ª—å—Ç—Ä: <b>–∫—Ä—É–≥–ª–æ—Å—Ç—å</b> (—Å–∏–ª—å–Ω–æ —Ä–µ–∂–µ—Ç –º–∏—Ü–µ–ª–∏–π/–ø—è—Ç–Ω–∞).
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <div class="small">Day1</div>
  <input id="img1" type="file" accept="image/*">
  <div class="small">Day2</div>
  <input id="img2" type="file" accept="image/*">

  <div class="row">
    <button id="show1" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day1</button>
    <button id="show2" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day2</button>
  </div>

  <button id="analyze" disabled>–ê–Ω–∞–ª–∏–∑ (–Ω–∞–π—Ç–∏ –≥—Ä–∏–±—ã + —Ä–æ—Å—Ç)</button>
  <div class="kv" id="out">–ó–∞–≥—Ä—É–∑–∏ –æ–±–∞ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card">
  <b>–ü—Ä–æ—Å–º–æ—Ç—Ä</b>
  <canvas id="cv"></canvas>
  <div class="small">–ü—Ä–∞–≤–∫–∏ –Ω–∞ Day2: Tap=toggle exclude ‚Ä¢ DoubleTap=add manual ‚Ä¢ Hold+Drag=move</div>

  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clearManual" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å manual</button>
    <button id="reset" class="secondary" disabled>–°–±—Ä–æ—Å –ø—Ä–∞–≤–æ–∫</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>

  <div class="small kv">üü¢ grown ‚Ä¢ üü° new ‚Ä¢ ‚ö™ same ‚Ä¢ üî¥ excluded ‚Ä¢ üü† manual</div>
</div>

<script>
const img1Input = document.getElementById("img1");
const img2Input = document.getElementById("img2");
const show1Btn = document.getElementById("show1");
const show2Btn = document.getElementById("show2");
const analyzeBtn = document.getElementById("analyze");

const outEl = document.getElementById("out");
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { willReadFrequently:true });

const undoBtn = document.getElementById("undo");
const clearManualBtn = document.getElementById("clearManual");
const resetBtn = document.getElementById("reset");
const exportBtn = document.getElementById("export");
const saveBtn = document.getElementById("savepng");

// ----- state -----
let day1=null, day2=null;
let view=2; // 1 or 2

let work = null;
/*
work = {
  W,H, dx,dy, score,
  blobs2: [{x,y,r, src:"auto|manual", excluded:false, cls:"grown|new|same", match:{r1,found}}],
  baseBlobs2: [...],
  meta: {growPx, maxDist, sc, circ}
}
*/

let history = [];
let dragging=false, dragIdx=-1;
let pressTimer=null;

let lastTapTime=0;
let lastTapPos=null;

// cached gray buffers for manual operations
let _g2=null, _g1a=null;

function setOut(t, cls=""){
  outEl.className = "kv " + cls;
  outEl.textContent = t;
}
function ready(){ return !!(day1 && day2); }

function updateUI(){
  const r = ready();
  show1Btn.disabled = !r;
  show2Btn.disabled = !r;
  analyzeBtn.disabled = !r;

  undoBtn.disabled = history.length===0;
  clearManualBtn.disabled = !(work && work.blobs2.some(b=>b.src==="manual"));
  resetBtn.disabled = !(work && work.baseBlobs2 && work.baseBlobs2.length);

  exportBtn.disabled = !work;
  saveBtn.disabled = !ready();
}

function pushHistory(){
  if(!work) return;
  history.push(JSON.stringify(work.blobs2));
  if(history.length > 120) history.shift();
  updateUI();
}

function invalidateWorkBuffers(){ _g2=null; _g1a=null; }

function fileToImg(f){
  return new Promise((resolve,reject)=>{
    const i = new Image();
    i.onload = ()=>resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function fitCanvasToImage(img){
  const maxW = 1100;
  const sc = Math.min(1, maxW / img.naturalWidth);
  cv.width  = Math.round(img.naturalWidth * sc);
  cv.height = Math.round(img.naturalHeight * sc);
}

function drawBaseImage(){
  if(!ready()) return;
  if(view===1){
    fitCanvasToImage(day1);
    ctx.drawImage(day1,0,0,cv.width,cv.height);
  }else{
    fitCanvasToImage(day2);
    ctx.drawImage(day2,0,0,cv.width,cv.height);
  }
}

function canvasXY(ev){
  const r = cv.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cv.width  / r.width);
  const y = (ev.clientY - r.top)  * (cv.height / r.height);
  return {x,y};
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function nearestBlobIdx(x,y, px=26){
  if(!work || view!==2) return -1;
  const sx = work.W / cv.width;
  const sy = work.H / cv.height;
  const wx = x * sx, wy = y * sy;
  const p = {x:wx,y:wy};
  const max2 = (px*sx)*(px*sx);

  let best=-1, bestD=1e18;
  for(let i=0;i<work.blobs2.length;i++){
    const b=work.blobs2[i];
    const d=dist2(b,p);
    if(d<max2 && d<bestD){ bestD=d; best=i; }
  }
  return best;
}

// ----- drawing -----
function strokeForBlob(b){
  if(b.excluded) return "#ff3333";
  if(b.src==="manual") return "#ff9900";
  if(b.cls==="grown") return "#00aa55";
  if(b.cls==="new") return "#ffd400";
  return "#ffffff";
}

function redraw(){
  if(!ready()) return;

  drawBaseImage();

  if(view===2 && work){
    const sx = cv.width / work.W;
    const sy = cv.height/ work.H;

    ctx.lineWidth = 3;
    for(const b of work.blobs2){
      const x = b.x*sx, y=b.y*sy;
      const r = Math.max(8, b.r*sx);
      ctx.strokeStyle = strokeForBlob(b);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
    }

    const grown = work.blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
    const news  = work.blobs2.filter(b=>!b.excluded && b.cls==="new").length;
    const all   = work.blobs2.filter(b=>!b.excluded).length;

    ctx.font = "14px ui-monospace, Menlo, monospace";
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(8,8,470,52);
    ctx.fillStyle = "#fff";
    ctx.fillText(`all: ${all}  grown: ${grown}  new: ${news}`, 14, 28);
    ctx.fillText(`align dx=${work.dx}, dy=${work.dy}`, 14, 46);
  }

  updateUI();
}

// ----- image processing -----
function toGray(rgba, n){
  const g = new Float32Array(n);
  for(let i=0;i<n;i++){
    const r=rgba[i*4], gg=rgba[i*4+1], b=rgba[i*4+2];
    g[i]=0.2126*r + 0.7152*gg + 0.0722*b;
  }
  return g;
}

function gaussianKernel1D(sigma, r){
  const k = new Float32Array(2*r+1);
  const s2 = sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v = Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function gaussianBlurSep(src,w,h,sigma){
  const r = Math.max(1, Math.ceil(sigma*2.5));
  const k = gaussianKernel1D(sigma, r);
  const tmp = new Float32Array(w*h);
  const dst = new Float32Array(w*h);

  for(let y=0;y<h;y++){
    const row=y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx=Math.min(w-1,Math.max(0,x+i));
        sum += src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy=Math.min(h-1,Math.max(0,y+i));
        sum += tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}

function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

function detectBlobsDoG(g,w,h){
  const bg = boxBlur(g,w,h,18);
  const x = new Float32Array(w*h);
  for(let i=0;i<w*h;i++) x[i] = g[i]-bg[i];

  const rMin = 6;
  const rMax = Math.min(70, Math.min(w,h)*0.12);

  const sigmas = [];
  for(let r=rMin; r<=rMax; r*=1.22){
    sigmas.push(r/1.4142);
    if(sigmas.length>18) break;
  }
  const blurs = sigmas.map(s => gaussianBlurSep(x,w,h,s));

  const candidates = [];
  const thr = 7.0;

  for(let k=0;k<blurs.length-1;k++){
    const a=blurs[k], b=blurs[k+1];
    const dog = new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i]=a[i]-b[i];

    const r = sigmas[k]*1.4142;
    for(let y=1;y<h-1;y++){
      for(let x2=1;x2<w-1;x2++){
        const idx=y*w+x2;
        const v=dog[idx];
        if(v < thr) continue;
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        candidates.push({x:x2,y,score:v,r});
      }
    }
  }

  candidates.sort((p,q)=>q.score-p.score);
  const kept=[];
  const minDist = 10;
  const minDist2 = minDist*minDist;

  for(const c of candidates){
    let ok=true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minDist2){ ok=false; break; }
    }
    if(!ok) continue;
    kept.push({x:c.x,y:c.y,r:c.r,score:c.score});
    if(kept.length>600) break;
  }
  return kept;
}

// ----- shift estimation -----
function resizeGrayNearest(src,SW,SH,W,H){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy = Math.min(SH-1, Math.max(0, Math.round(y*SH/H)));
    for(let x=0;x<W;x++){
      const sx = Math.min(SW-1, Math.max(0, Math.round(x*SW/W)));
      dst[y*W+x]=src[sy*SW+sx];
    }
  }
  return dst;
}
function gradMag(g,W,H){
  const out = new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i=y*W+x;
      const gx=g[i+1]-g[i-1];
      const gy=g[i+W]-g[i-W];
      out[i]=Math.abs(gx)+Math.abs(gy);
    }
  }
  return out;
}
function estimateShift(g1,g2,W,H){
  const max=260;
  const sc = Math.min(1, max / W);
  const w = Math.max(90, Math.round(W*sc));
  const h = Math.max(90, Math.round(H*sc));

  const a = resizeGrayNearest(g1,W,H,w,h);
  const b = resizeGrayNearest(g2,W,H,w,h);
  const ag = gradMag(a,w,h);
  const bg = gradMag(b,w,h);

  const range = 24;
  const x0=Math.floor(w*0.15), x1=Math.floor(w*0.85);
  const y0=Math.floor(h*0.15), y1=Math.floor(h*0.85);

  let best={dx:0,dy:0,score:Infinity};

  for(let dy=-range; dy<=range; dy++){
    for(let dx=-range; dx<=range; dx++){
      let s=0, cnt=0;
      for(let y=y0; y<y1; y++){
        const sy=y-dy;
        if(sy<y0||sy>=y1) continue;
        const row=y*w, srow=sy*w;
        for(let x=x0; x<x1; x++){
          const sx=x-dx;
          if(sx<x0||sx>=x1) continue;
          s += Math.abs(bg[row+x]-ag[srow+sx]);
          cnt++;
        }
      }
      if(cnt){
        const score=s/cnt;
        if(score<best.score) best={dx,dy,score};
      }
    }
  }
  return {dx:Math.round(best.dx/sc), dy:Math.round(best.dy/sc), score:best.score};
}

function shiftGray(src,W,H,dx,dy){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy=y-dy;
    if(sy<0||sy>=H) continue;
    for(let x=0;x<W;x++){
      const sx=x-dx;
      if(sx<0||sx>=W) continue;
      dst[y*W+x]=src[sy*W+sx];
    }
  }
  return dst;
}

// ----- radius + circularity -----
// estimate best radius by edge strength along circle
function estimateRadiusAt(gray,W,H,cx,cy, rMin=6, rMax=90){
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return null;

  const N = 24;
  let bestR=null, bestS=0;

  for(let r=rMin; r<=rMax; r+=2){
    let s=0, cnt=0;
    for(let k=0;k<N;k++){
      const ang = (k/N)*Math.PI*2;
      const x = x0 + Math.cos(ang)*r;
      const y = y0 + Math.sin(ang)*r;
      const ix = Math.round(x), iy = Math.round(y);
      if(ix<1||iy<1||ix>=W-1||iy>=H-1) continue;

      const i=iy*W+ix;
      const gx = gray[i+1]-gray[i-1];
      const gy = gray[i+W]-gray[i-W];
      s += Math.abs(gx)+Math.abs(gy);
      cnt++;
    }
    if(cnt){
      const avg = s/cnt;
      if(avg > bestS){
        bestS = avg;
        bestR = r;
      }
    }
  }

  if(bestR===null) return null;
  if(bestS < 10) return null; // edge too weak
  return bestR;
}

// circularity gate: ring edge uniformity + inside/outside contrast
function circleQuality(gray,W,H,cx,cy,r){
  const N=24;
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return {ok:false, reason:"oob"};

  const rin  = Math.max(2, Math.round(r*0.70));
  const rout = Math.max(r+2, Math.round(r*1.15));

  let edgeSum=0, edgeSum2=0, edgeCnt=0;
  let inSum=0, inCnt=0;
  let outSum=0, outCnt=0;

  for(let k=0;k<N;k++){
    const ang = (k/N)*Math.PI*2;
    const cs = Math.cos(ang), sn = Math.sin(ang);

    // edge at r
    {
      const x = x0 + cs*r;
      const y = y0 + sn*r;
      const ix = Math.round(x), iy = Math.round(y);
      if(ix<1||iy<1||ix>=W-1||iy>=H-1) continue;
      const i=iy*W+ix;
      const gx = gray[i+1]-gray[i-1];
      const gy = gray[i+W]-gray[i-W];
      const e = Math.abs(gx)+Math.abs(gy);
      edgeSum += e; edgeSum2 += e*e; edgeCnt++;
    }

    // inside sample
    {
      const x = x0 + cs*rin;
      const y = y0 + sn*rin;
      const ix = Math.round(x), iy = Math.round(y);
      if(ix>=0&&iy>=0&&ix<W&&iy<H){
        inSum += gray[iy*W+ix]; inCnt++;
      }
    }

    // outside sample
    {
      const x = x0 + cs*rout;
      const y = y0 + sn*rout;
      const ix = Math.round(x), iy = Math.round(y);
      if(ix>=0&&iy>=0&&ix<W&&iy<H){
        outSum += gray[iy*W+ix]; outCnt++;
      }
    }
  }

  if(edgeCnt < 12 || inCnt < 12 || outCnt < 12) return {ok:false, reason:"sparse"};

  const edgeMean = edgeSum/edgeCnt;
  const edgeStd  = Math.sqrt(Math.max(1e-6, edgeSum2/edgeCnt - edgeMean*edgeMean));
  const edgeCV   = edgeStd / Math.max(1e-6, edgeMean);

  const inMean = inSum/inCnt;
  const outMean= outSum/outCnt;
  const contrast = inMean - outMean; // mushroom cap tends to be brighter than surrounding

  // thresholds (tuned for your trays)
  const okEdge = edgeMean >= 10;         // must have clear boundary
  const okCV   = edgeCV <= 0.85;         // too ragged => mycelium/clumps
  const okCon  = contrast >= 6;          // inside brighter than outside (helps kill mycelium)

  return {ok: (okEdge && okCV && okCon), edgeMean, edgeCV, contrast};
}

function getWorkGrayDay2(){
  if(_g2) return _g2;
  const W=work.W,H=work.H;
  const c=document.createElement("canvas");
  c.width=W; c.height=H;
  const x=c.getContext("2d",{willReadFrequently:true});
  x.drawImage(day2,0,0,W,H);
  const im=x.getImageData(0,0,W,H);
  _g2 = toGray(im.data,W*H);
  return _g2;
}
function getWorkGrayDay1Aligned(){
  if(_g1a) return _g1a;
  const W=work.W,H=work.H;
  const c=document.createElement("canvas");
  c.width=W; c.height=H;
  const x=c.getContext("2d",{willReadFrequently:true});
  x.drawImage(day1,0,0,W,H);
  const im=x.getImageData(0,0,W,H);
  const g1=toGray(im.data,W*H);
  _g1a = shiftGray(g1,W,H,work.dx,work.dy);
  return _g1a;
}

// ----- analyze growth -----
async function runAnalyze(){
  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶", "warn");

  const maxW=900;
  const sc = Math.min(1, maxW / day2.naturalWidth);
  const W = Math.round(day2.naturalWidth*sc);
  const H = Math.round(day2.naturalHeight*sc);

  const c1=document.createElement("canvas");
  const c2=document.createElement("canvas");
  c1.width=W; c1.height=H;
  c2.width=W; c2.height=H;
  const x1=c1.getContext("2d",{willReadFrequently:true});
  const x2=c2.getContext("2d",{willReadFrequently:true});
  x1.drawImage(day1,0,0,W,H);
  x2.drawImage(day2,0,0,W,H);

  const im1=x1.getImageData(0,0,W,H);
  const im2=x2.getImageData(0,0,W,H);
  const g1=toGray(im1.data,W*H);
  const g2=toGray(im2.data,W*H);

  setOut("–ê–Ω–∞–ª–∏–∑: –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ Day1 ‚Üí Day2‚Ä¶", "warn");
  const {dx,dy,score} = estimateShift(g1,g2,W,H);
  const g1a = shiftGray(g1,W,H,dx,dy);

  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–∏—Å–∫ –≥—Ä–∏–±–æ–≤ –Ω–∞ Day2 (blob)‚Ä¶", "warn");
  const raw2 = detectBlobsDoG(g2,W,H);

  // circularity thresholds (–º–æ–∂–Ω–æ –ø–æ—Ç–æ–º –ø–æ–¥—Å—Ç—Ä–æ–∏—Ç—å, –µ—Å–ª–∏ –Ω–∞–¥–æ)
  const circ = {
    edgeMeanMin: 10,
    edgeCVMax: 0.85,
    contrastMin: 6
  };

  // refine & filter by circularity
  const blobs2 = [];
  let rejected = 0;

  for(const b of raw2){
    const rGuessMin = Math.max(6, Math.round(b.r*0.7));
    const rGuessMax = Math.min(90, Math.round(b.r*1.6));
    const r2 = estimateRadiusAt(g2,W,H,b.x,b.y, rGuessMin, rGuessMax);
    if(r2===null) { rejected++; continue; }
    if(r2 < 6) { rejected++; continue; }
    if(r2 > Math.min(W,H)*0.14) { rejected++; continue; }

    const q = circleQuality(g2,W,H,b.x,b.y,r2);
    // apply thresholds
    const ok =
      q.ok &&
      q.edgeMean >= circ.edgeMeanMin &&
      q.edgeCV <= circ.edgeCVMax &&
      q.contrast >= circ.contrastMin;

    if(!ok){
      rejected++;
      continue;
    }

    blobs2.push({x:b.x,y:b.y,r:r2, src:"auto", excluded:false, cls:"same", match:{found:false, r1:null}});
  }

  setOut("–ê–Ω–∞–ª–∏–∑: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ Day1 vs Day2‚Ä¶", "warn");

  const growPx = 2.5;
  const maxDist = 18;
  const maxR = 90;

  for(const b of blobs2){
    let best = {r1:null, s:0};
    for(let oy=-maxDist; oy<=maxDist; oy+=3){
      for(let ox=-maxDist; ox<=maxDist; ox+=3){
        const cx=b.x+ox, cy=b.y+oy;
        if(cx<2||cy<2||cx>=W-2||cy>=H-2) continue;
        const r1 = estimateRadiusAt(g1a,W,H,cx,cy, Math.max(6, Math.round(b.r*0.6)), Math.min(maxR, Math.round(b.r*1.6)));
        if(r1===null) continue;
        const clos = 1 / (1 + Math.abs(r1 - b.r));
        const scv = clos;
        if(scv > best.s){
          best = {r1, s: scv};
        }
      }
    }

    if(best.r1===null){
      b.cls = "new";
      b.match = {found:false, r1:null};
    }else{
      b.match = {found:true, r1:best.r1};
      b.cls = (b.r - best.r1) >= growPx ? "grown" : "same";
    }
  }

  work = {
    W,H, dx,dy, score,
    blobs2,
    baseBlobs2: JSON.parse(JSON.stringify(blobs2)),
    meta: {growPx, maxDist, sc, circ, rejected}
  };
  history = [];
  invalidateWorkBuffers(); // rebuild lazily for manual
  view = 2;

  const grownN = blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
  const newN   = blobs2.filter(b=>!b.excluded && b.cls==="new").length;
  const allN   = blobs2.filter(b=>!b.excluded).length;

  setOut(
    `–ì–æ—Ç–æ–≤–æ.
–°–¥–≤–∏–≥: dx=${dx}, dy=${dy} (score=${score.toFixed(1)})
–ù–∞–π–¥–µ–Ω–æ –≥—Ä–∏–±–æ–≤ (Day2): ${allN}
–í—ã—Ä–æ—Å–ª–æ: ${grownN}
–ù–æ–≤—ã–µ: ${newN}
–û—Ç–±—Ä–∞–∫–æ–≤–∞–Ω–æ –∫—Ä—É–≥–ª—ã–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏: ${rejected}
–ü–æ—Ä–æ–≥ —Ä–æ—Å—Ç–∞: +${growPx}px —Ä–∞–¥–∏—É—Å–∞`,
    "ok"
  );

  redraw();
}

// ----- Editing Day2 (semi-auto) -----
function toggleExcludeAt(x,y){
  const idx = nearestBlobIdx(x,y,28);
  if(idx<0) return;
  pushHistory();
  work.blobs2[idx].excluded = !work.blobs2[idx].excluded;
  redraw();
}

function addManualAt(x,y){
  if(!work) return;
  const sx = work.W / cv.width;
  const sy = work.H / cv.height;
  const wx = x * sx;
  const wy = y * sy;

  pushHistory();

  const g2 = getWorkGrayDay2();
  const g1a = getWorkGrayDay1Aligned();

  let r = estimateRadiusAt(g2, work.W, work.H, wx, wy, 8, 90);
  if(r===null) r=18;

  // manual: –∫—Ä—É–≥–ª—ã–π —Ñ–∏–ª—å—Ç—Ä –º—è–≥—á–µ (—á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ ‚Äú–¥–æ–±–∞–≤–∏—Ç—å‚Äù —Ç–æ, —á—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∫–∞ –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∞)
  const q = circleQuality(g2, work.W, work.H, wx, wy, r);
  if(!q.ok && r < 14) r = 18;

  const b = {x:wx, y:wy, r, src:"manual", excluded:false, cls:"new", match:{found:false, r1:null}};

  const r1 = estimateRadiusAt(g1a, work.W, work.H, wx, wy, Math.max(6, Math.round(r*0.6)), Math.min(90, Math.round(r*1.6)));
  if(r1!==null){
    b.match = {found:true, r1};
    b.cls = (r - r1) >= work.meta.growPx ? "grown" : "same";
  }else{
    b.cls = "new";
  }

  work.blobs2.push(b);
  redraw();
}

function startDragAt(x,y){
  const idx = nearestBlobIdx(x,y,32);
  if(idx<0) return false;
  pushHistory();
  dragging=true;
  dragIdx=idx;
  if(work.blobs2[idx].src==="auto") work.blobs2[idx].src="manual";
  return true;
}

function moveDragTo(x,y){
  if(!dragging || dragIdx<0) return;
  const sx = work.W / cv.width;
  const sy = work.H / cv.height;
  const b = work.blobs2[dragIdx];
  b.x = x*sx;
  b.y = y*sy;

  const g2 = getWorkGrayDay2();
  const g1a = getWorkGrayDay1Aligned();

  const r2 = estimateRadiusAt(g2, work.W, work.H, b.x, b.y, 8, 90);
  if(r2) b.r = r2;

  const r1 = estimateRadiusAt(g1a, work.W, work.H, b.x, b.y, Math.max(6, Math.round(b.r*0.6)), Math.min(90, Math.round(b.r*1.6)));
  if(r1!==null){
    b.match = {found:true, r1};
    b.cls = (b.r - r1) >= work.meta.growPx ? "grown" : "same";
  }else{
    b.match = {found:false, r1:null};
    b.cls = "new";
  }

  redraw();
}

function endDrag(){
  dragging=false;
  dragIdx=-1;
}

// ----- UI wiring -----
img1Input.addEventListener("change", async ()=>{
  work=null; history=[]; invalidateWorkBuffers();
  try{
    day1 = await fileToImg(img1Input.files[0]);
    setOut("Day1 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day2.", "warn");
  }catch(e){
    day1=null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day1.", "bad");
  }
  if(ready()){
    view=2;
    setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  redraw(); updateUI();
});

img2Input.addEventListener("change", async ()=>{
  work=null; history=[]; invalidateWorkBuffers();
  try{
    day2 = await fileToImg(img2Input.files[0]);
    setOut("Day2 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day1.", "warn");
  }catch(e){
    day2=null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day2.", "bad");
  }
  if(ready()){
    view=2;
    setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  redraw(); updateUI();
});

show1Btn.addEventListener("click", ()=>{ view=1; redraw(); });
show2Btn.addEventListener("click", ()=>{ view=2; redraw(); });

analyzeBtn.addEventListener("click", async ()=>{
  if(!ready()) return;
  invalidateWorkBuffers();
  await runAnalyze();
});

undoBtn.addEventListener("click", ()=>{
  if(!history.length || !work) return;
  work.blobs2 = JSON.parse(history.pop());
  redraw();
});

clearManualBtn.addEventListener("click", ()=>{
  if(!work) return;
  pushHistory();
  work.blobs2 = work.blobs2.filter(b=>b.src!=="manual");
  redraw();
});

resetBtn.addEventListener("click", ()=>{
  if(!work) return;
  history=[];
  work.blobs2 = JSON.parse(JSON.stringify(work.baseBlobs2));
  redraw();
});

exportBtn.addEventListener("click", ()=>{
  if(!work) return;
  const payload = {
    version: "MWC_B2_SEMIAUTO_GROWTH_CIRC",
    created_at: new Date().toISOString(),
    align: {dx: work.dx, dy: work.dy, score: work.score},
    work_size: {W: work.W, H: work.H},
    params: work.meta,
    blobs_day2: work.blobs2
  };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="mwc_b2_growth_circ.json";
  a.click();
});

saveBtn.addEventListener("click", ()=>{
  if(!ready()) return;
  redraw();
  const a=document.createElement("a");
  a.href=cv.toDataURL("image/png");
  a.download = view===2 ? "mwc_b2_day2_marked.png" : "mwc_b2_day1.png";
  a.click();
});

// ----- Canvas interactions (Day2 only) -----
cv.addEventListener("mousedown", (ev)=>{
  if(!work || view!==2) return;
  const p=canvasXY(ev);
  pressTimer = setTimeout(()=> startDragAt(p.x,p.y), 180);
});
cv.addEventListener("mousemove", (ev)=>{
  if(!work || view!==2 || !dragging) return;
  const p=canvasXY(ev);
  moveDragTo(p.x,p.y);
});
cv.addEventListener("mouseup", (ev)=>{
  if(!work || view!==2) return;
  clearTimeout(pressTimer);
  const p=canvasXY(ev);

  if(dragging){ endDrag(); return; }

  const now=Date.now();
  const isDouble = (now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(isDouble) addManualAt(p.x,p.y);
  else toggleExcludeAt(p.x,p.y);
});

// iOS touch
cv.addEventListener("touchstart", (ev)=>{
  if(!work || view!==2) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);

  pressTimer = setTimeout(()=> startDragAt(p.x,p.y), 180);

  const now=Date.now();
  const isDouble = (now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(isDouble){
    clearTimeout(pressTimer);
    addManualAt(p.x,p.y);
  }
}, {passive:false});

cv.addEventListener("touchmove", (ev)=>{
  if(!work || view!==2 || !dragging) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);
  moveDragTo(p.x,p.y);
}, {passive:false});

cv.addEventListener("touchend", (ev)=>{
  if(!work || view!==2) return;
  ev.preventDefault();
  clearTimeout(pressTimer);

  if(dragging){ endDrag(); return; }

  const t=ev.changedTouches[0];
  const p=canvasXY(t);
  const now=Date.now();
  const isDouble = (now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  if(!isDouble) toggleExcludeAt(p.x,p.y);
}, {passive:false});

// init
updateUI();
</script>
</body>
</html>
