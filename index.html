<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî A2.0 SIMPLE</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .ok{color:#0a7;font-weight:700}
  .bad{color:#c00;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:150px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#333}
</style>
</head>

<body>
<h1>MWC ‚Äî A2.0 SIMPLE (–∞–≤—Ç–æ-—Ä–∞–º–∫–∞, —Å—á–∏—Ç–∞–µ–º ‚â•4 –º–º)</h1>
<div class="small">
–†–∞–º–∫–∞ 20√ó20 —Å–º (200 –º–º). –ê–≤—Ç–æ-–ø–æ–∏—Å–∫ —Ä–∞–º–∫–∏ ‚Üí warp 800√ó800.<br>
<b>–ñ–µ—Å—Ç—ã:</b> Tap=toggle ‚Ä¢ DoubleTap=add ‚Ä¢ Hold+Drag=move
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <button id="run" disabled>–ê–Ω–∞–ª–∏–∑</button>
  <div class="small" id="hint">–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card"><pre id="out">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</pre></div>

<div class="card">
  <b>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ (–∞–≤—Ç–æ-—Ä–∞–º–∫–∞)</b>
  <canvas id="src"></canvas>
  <div class="small">–ó–µ–ª—ë–Ω—ã–º ‚Äî –Ω–∞–π–¥–µ–Ω–Ω–∞—è —Ä–∞–º–∫–∞.</div>
</div>

<div class="card">
  <b>–†–∞—Å–ø—Ä–µ–º–ª—ë–Ω–Ω–∞—è —Ä–∞–º–∫–∞ (800√ó800)</b>
  <canvas id="rect"></canvas>
  <div class="small kv" id="live">–ò—Ç–æ–≥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞‚Ä¶</div>

  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clearManual" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å manual</button>
    <button id="resetEdits" class="secondary" disabled>–°–±—Ä–æ—Å –ø—Ä–∞–≤–æ–∫</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>
  <div class="small kv">üü¢ auto ‚Ä¢ üü° manual ‚Ä¢ üî¥ excluded</div>
</div>

<script>
// ----------------- DOM -----------------
const input = document.getElementById("img");
const runBtn = document.getElementById("run");
const hint = document.getElementById("hint");
const out  = document.getElementById("out");

const cSrc = document.getElementById("src");
const cRect= document.getElementById("rect");
const srcCtx = cSrc.getContext("2d", { willReadFrequently:true });
const rectCtx= cRect.getContext("2d", { willReadFrequently:true });

const liveEl = document.getElementById("live");

const undoBtn = document.getElementById("undo");
const clearManualBtn = document.getElementById("clearManual");
const resetEditsBtn = document.getElementById("resetEdits");
const exportBtn = document.getElementById("export");
const savePngBtn = document.getElementById("savepng");

// ----------------- Constants -----------------
const RECT = 800;
const FRAME_MM = 200;                  // 20 cm
const mmPerPx = FRAME_MM / RECT;       // 0.25
const CALIB = 1.15;                    // –º–æ–∂–Ω–æ –ø–æ—Ç–æ–º –≤—ã–Ω–µ—Å—Ç–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫—É, –Ω–æ —Å–µ–π—á–∞—Å —Ñ–∏–∫—Å
const DMIN_MM = 4.0;                   // —Ñ–∏–∫—Å (–∫–∞–∫ —Ç—ã –ø—Ä–æ—Å–∏–ª)
const DMAX_DETECT_MM = 60.0;           // –ø–æ—Ç–æ–ª–æ–∫ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞
const PICK_R = 28;

// ----------------- State -----------------
let imgObj = null;

let points = [];        // auto + manual + excluded
let basePoints = [];
let history = [];
let lastWarped = null;

// iOS touch state
let lastTapTime = 0;
let lastTapPos = null;
let doubleHandled = false;

let dragging = false;
let dragIdx = -1;
let pressTimer = null;

// corners (–∞–≤—Ç–æ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ) in source-canvas coords: [LT, RT, RB, LB]
let autoCorners = null;

function setOut(t, cls=""){ out.className = cls; out.textContent = t; }

function updateUI(){
  runBtn.disabled = !imgObj;
  undoBtn.disabled = history.length === 0;
  clearManualBtn.disabled = points.filter(p=>p.src==="manual").length === 0;
  resetEditsBtn.disabled = basePoints.length === 0;
  exportBtn.disabled = points.length === 0;
  savePngBtn.disabled = !lastWarped;

  if(!imgObj) hint.textContent = "–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.";
  else hint.textContent = "–ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.";
}

function clonePts(arr){ return arr.map(p => ({...p})); }
function pushHistory(){
  history.push(JSON.stringify(points));
  if(history.length > 80) history.shift();
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
function nearestPoint(x,y, maxPx=PICK_R){
  let best = null;
  const p0 = {x,y};
  const max2 = maxPx*maxPx;
  for(let i=0;i<points.length;i++){
    const p = points[i];
    const d = dist2(p, p0);
    if(d <= max2 && (!best || d < best.d2)) best = {i, d2:d};
  }
  return best ? best.i : -1;
}
function canvasXY(ev, canvas){
  const r = canvas.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (canvas.width  / r.width);
  const y = (ev.clientY - r.top)  * (canvas.height / r.height);
  return {x,y};
}

// ----------------- Stats -----------------
function classify(dMm){
  if(dMm < 6) return "4‚Äì6";
  if(dMm < 10) return "6‚Äì10";
  if(dMm < 20) return "10‚Äì20";
  return "20+";
}
function stats(){
  let n=0, sum=0;
  let buckets = {"4‚Äì6":0,"6‚Äì10":0,"10‚Äì20":0,"20+":0};
  for(const p of points){
    if(p.excluded) continue;
    if(p.dMm < DMIN_MM) continue;
    n++; sum += p.dMm;
    const cls = classify(p.dMm);
    buckets[cls] += 1;
  }
  return { n, avg: n? (sum/n):0, buckets };
}

// ----------------- Draw -----------------
function redrawRect(){
  if(!lastWarped) return;

  rectCtx.putImageData(lastWarped, 0, 0);

  for(const p of points){
    const active = !p.excluded;
    const isManual = p.src === "manual";

    rectCtx.lineWidth = 3;
    if(!active) rectCtx.strokeStyle = "#ff3333";
    else if(isManual) rectCtx.strokeStyle = "#ffd400";
    else rectCtx.strokeStyle = "#00ff00";

    rectCtx.beginPath();
    rectCtx.arc(p.x, p.y, Math.max(6, p.r), 0, Math.PI*2);
    rectCtx.stroke();
  }

  const st = stats();
  const manualCount = points.filter(p=>p.src==="manual" && !p.excluded && p.dMm>=DMIN_MM).length;
  const excludedCount = points.filter(p=>p.excluded).length;

  const text =
`–ì—Ä–∏–±—ã ‚â• 4.0 –º–º: ${st.n}
–°—Ä–µ–¥–Ω–∏–π –¥–∏–∞–º–µ—Ç—Ä: ${st.avg.toFixed(1)} –º–º
–ö–ª–∞—Å—Å—ã: 4‚Äì6=${st.buckets["4‚Äì6"]}, 6‚Äì10=${st.buckets["6‚Äì10"]}, 10‚Äì20=${st.buckets["10‚Äì20"]}, 20+=${st.buckets["20+"]}
–ú–∞—Å—à—Ç–∞–±: ${mmPerPx.toFixed(4)} –º–º/px  Calib: √ó${CALIB.toFixed(2)}
–ü—Ä–∞–≤–∫–∏: manual=${manualCount}, excluded=${excludedCount}`;

  setOut(text, st.n ? "ok" : "bad");
  if(liveEl) liveEl.textContent = text;

  updateUI();
}

function drawSourceWithCorners(corners){
  // draw source
  const maxW = 1100;
  const sc = Math.min(1, maxW / imgObj.naturalWidth);
  const w = Math.round(imgObj.naturalWidth * sc);
  const h = Math.round(imgObj.naturalHeight * sc);
  cSrc.width = w; cSrc.height = h;
  srcCtx.drawImage(imgObj, 0, 0, w, h);

  if(!corners) return;

  srcCtx.lineWidth = 4;
  srcCtx.strokeStyle = "#00ff00";
  srcCtx.fillStyle = "#00ff00";

  // poly
  srcCtx.beginPath();
  srcCtx.moveTo(corners[0].x, corners[0].y);
  srcCtx.lineTo(corners[1].x, corners[1].y);
  srcCtx.lineTo(corners[2].x, corners[2].y);
  srcCtx.lineTo(corners[3].x, corners[3].y);
  srcCtx.closePath();
  srcCtx.stroke();

  for(const p of corners){
    srcCtx.beginPath(); srcCtx.arc(p.x,p.y,7,0,Math.PI*2); srcCtx.fill();
  }
}

// ----------------- File load -----------------
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

input.addEventListener("change", async () => {
  autoCorners = null;
  points = []; basePoints = []; history = []; lastWarped = null;
  try{
    imgObj = await fileToImg(input.files[0]);
    drawSourceWithCorners(null);
    setOut("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "warn");
    if(liveEl) liveEl.textContent = "–ò—Ç–æ–≥ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞‚Ä¶";
  }catch(e){
    imgObj = null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "bad");
  }
  updateUI();
});

// ----------------- Auto frame detection -----------------
// We detect the largest rectangle by edges + Hough-like line voting (simple, no libs).
// Works best when frame is visible and high-contrast.
function detectFrameCorners(imageData, w, h){
  const d = imageData.data;

  // grayscale
  const g = new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++){
    const r=d[i*4], gg=d[i*4+1], b=d[i*4+2];
    g[i] = (0.2126*r + 0.7152*gg + 0.0722*b) | 0;
  }

  // sobel edges
  const mag = new Float32Array(w*h);
  const gxK = [-1,0,1,-2,0,2,-1,0,1];
  const gyK = [-1,-2,-1,0,0,0,1,2,1];

  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let gx=0, gy=0;
      let k=0;
      for(let yy=-1;yy<=1;yy++){
        for(let xx=-1;xx<=1;xx++){
          const v = g[(y+yy)*w + (x+xx)];
          gx += v*gxK[k];
          gy += v*gyK[k];
          k++;
        }
      }
      mag[y*w+x] = Math.hypot(gx,gy);
    }
  }

  // threshold edges (adaptive-ish)
  let sum=0; for(let i=0;i<mag.length;i++) sum += mag[i];
  const mean = sum/mag.length;
  const thr = mean * 2.2;

  // voting for vertical/horizontal lines:
  // for each x column, count strong edges -> likely vertical frame borders
  const col = new Int32Array(w);
  const row = new Int32Array(h);

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      if(mag[y*w+x] > thr){
        col[x]++; row[y]++;
      }
    }
  }

  function topPeaks(arr, k=6, minSep=20){
    // return indices of strongest peaks
    const idx = Array.from(arr.keys());
    idx.sort((a,b)=>arr[b]-arr[a]);
    const peaks=[];
    for(const i of idx){
      if(arr[i] <= 0) break;
      if(peaks.every(p=>Math.abs(p-i) >= minSep)){
        peaks.push(i);
        if(peaks.length>=k) break;
      }
    }
    peaks.sort((a,b)=>a-b);
    return peaks;
  }

  const xs = topPeaks(col, 8, Math.max(10, (w*0.03)|0));
  const ys = topPeaks(row, 8, Math.max(10, (h*0.03)|0));

  if(xs.length < 2 || ys.length < 2) return null;

  // choose farthest pair (left,right) and (top,bottom)
  let left=xs[0], right=xs[xs.length-1];
  let top=ys[0], bottom=ys[ys.length-1];

  // sanity: ensure rectangle big enough
  if((right-left) < w*0.35 || (bottom-top) < h*0.35) return null;

  // corners in this downscaled space
  return [
    {x:left, y:top},
    {x:right, y:top},
    {x:right, y:bottom},
    {x:left, y:bottom},
  ];
}

// ----------------- Warp -----------------
function warpToRect(sourceCanvas, srcPts, dstW, dstH){
  const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
  const H = computeHomography(dstPts, srcPts);

  const sCtx = sourceCanvas.getContext("2d", { willReadFrequently:true });
  const sW = sourceCanvas.width, sH = sourceCanvas.height;
  const sData = sCtx.getImageData(0,0,sW,sH).data;

  const out = new ImageData(dstW, dstH);
  const o = out.data;

  for(let y=0;y<dstH;y++){
    for(let x=0;x<dstW;x++){
      const [sx, sy] = applyH(H, x, y);
      const ix = Math.floor(sx), iy = Math.floor(sy);
      const di = (y*dstW + x)*4;
      if (ix>=0 && iy>=0 && ix<sW && iy<sH){
        const si = (iy*sW + ix)*4;
        o[di]=sData[si]; o[di+1]=sData[si+1]; o[di+2]=sData[si+2]; o[di+3]=255;
      } else { o[di]=o[di+1]=o[di+2]=0; o[di+3]=255; }
    }
  }
  return out;
}
function applyH(H, x, y){
  const a = H[0]*x + H[1]*y + H[2];
  const b = H[3]*x + H[4]*y + H[5];
  const c = H[6]*x + H[7]*y + H[8];
  return [a/c, b/c];
}
function computeHomography(p, q){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const x=p[i].x, y=p[i].y, u=q[i].x, v=q[i].y;
    A.push([x,y,1,0,0,0,-x*u,-y*u]); b.push(u);
    A.push([0,0,0,x,y,1,-x*v,-y*v]); b.push(v);
  }
  const h = solve8(A,b);
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7],1];
}
function solve8(A,b){
  const n=8, M=A.map((r,i)=>r.concat([b[i]]));
  for(let c=0;c<n;c++){
    let p=c; for(let r=c+1;r<n;r++) if(Math.abs(M[r][c])>Math.abs(M[p][c])) p=r;
    [M[c],M[p]]=[M[p],M[c]];
    const d=M[c][c]||1e-12; for(let j=c;j<=n;j++) M[c][j]/=d;
    for(let r=0;r<n;r++){ if(r===c) continue; const f=M[r][c]; for(let j=c;j<=n;j++) M[r][j]-=f*M[c][j]; }
  }
  return M.map(r=>r[n]);
}

// ----------------- DoG blob detection (fixed) -----------------
function rpxFromMmDetect(dmm){ return (dmm/2) / mmPerPx; }

function detectBlobsDoG(imageData, w, h){
  // fixed threshold tuned for your scenes
  const thr2 = 7.0;

  const d = imageData.data;
  const g = new Float32Array(w*h);
  for(let i=0;i<w*h;i++){
    g[i] = 0.2126*d[i*4] + 0.7152*d[i*4+1] + 0.0722*d[i*4+2];
  }

  const bg = boxBlur(g,w,h,18);
  for(let i=0;i<w*h;i++) g[i] = g[i] - bg[i];

  const rMin = rpxFromMmDetect(3.5);
  const rMax = rpxFromMmDetect(DMAX_DETECT_MM);

  const sigmas = [];
  for(let r=rMin; r<=rMax; r*=1.22){
    sigmas.push(r/1.4142);
    if(sigmas.length > 18) break;
  }
  const blurs = sigmas.map(s => gaussianBlurSep(g,w,h,s));

  const candidates = [];
  for(let k=0;k<blurs.length-1;k++){
    const a = blurs[k], b2 = blurs[k+1];
    const dog = new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i] = a[i] - b2[i];

    const r = sigmas[k]*1.4142;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const idx = y*w + x;
        const v = dog[idx];
        if(v < thr2) continue;
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        candidates.push({x,y,score:v,r});
      }
    }
  }

  candidates.sort((p,q)=>q.score-p.score);
  const kept = [];
  const minDist = 10;
  const minDist2 = minDist*minDist;

  for(const c of candidates){
    let ok = true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minDist2){ ok=false; break; }
    }
    if(!ok) continue;

    const dMm = (2*c.r) * mmPerPx * CALIB;
    if(dMm < 2.5) continue;
    if(dMm > (DMAX_DETECT_MM + 5)) continue;

    kept.push({ x:c.x, y:c.y, r:c.r, dMm });
    if(kept.length > 500) break;
  }
  return kept;
}

// ----------------- blurs -----------------
function gaussianBlurSep(src,w,h,sigma){
  const r = Math.max(1, Math.ceil(sigma*2.5));
  const k = gaussianKernel1D(sigma, r);
  const tmp = new Float32Array(w*h);
  const dst = new Float32Array(w*h);

  for(let y=0;y<h;y++){
    const row = y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx = Math.min(w-1, Math.max(0, x+i));
        sum += src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy = Math.min(h-1, Math.max(0, y+i));
        sum += tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}
function gaussianKernel1D(sigma, r){
  const k = new Float32Array(2*r+1);
  const s2 = sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v = Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

// ----------------- Analyze -----------------
runBtn.addEventListener("click", ()=>{
  if(!imgObj) return;

  setOut("–ü–æ–∏—Å–∫ —Ä–∞–º–∫–∏‚Ä¶", "warn");

  // draw source first
  drawSourceWithCorners(null);

  // downscale for detection (fast)
  const detW = 520;
  const detH = Math.round(cSrc.height * (detW / cSrc.width));
  const tmp = document.createElement("canvas");
  tmp.width = detW; tmp.height = detH;
  const tctx = tmp.getContext("2d", { willReadFrequently:true });
  tctx.drawImage(cSrc, 0, 0, detW, detH);

  const imgD = tctx.getImageData(0,0,detW,detH);
  const detCorners = detectFrameCorners(imgD, detW, detH);

  if(!detCorners){
    setOut("–ù–µ —Å–º–æ–≥ –Ω–∞–π—Ç–∏ —Ä–∞–º–∫—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –°–¥–µ–ª–∞–π —Ñ–æ—Ç–æ —Ç–∞–∫, —á—Ç–æ–±—ã —Ä–∞–º–∫–∞ –±—ã–ª–∞ —Ü–µ–ª–∏–∫–æ–º –≤ –∫–∞–¥—Ä–µ.", "bad");
    return;
  }

  // scale corners back to source canvas coords
  const sx = cSrc.width / detW;
  const sy = cSrc.height / detH;
  autoCorners = detCorners.map(p => ({x:p.x*sx, y:p.y*sy}));

  drawSourceWithCorners(autoCorners);
  setOut("–†–∞–º–∫–∞ –Ω–∞–π–¥–µ–Ω–∞. Warp + –ø–æ–¥—Å—á—ë—Ç‚Ä¶", "warn");

  // warp
  const warped = warpToRect(cSrc, autoCorners, RECT, RECT);
  lastWarped = warped;

  cRect.width = RECT; cRect.height = RECT;
  rectCtx.putImageData(warped, 0, 0);

  // detect blobs
  const result = detectBlobsDoG(warped, RECT, RECT);

  basePoints = result.map(p => ({...p, src:"auto", excluded:false}));
  points = clonePts(basePoints);
  history = [];

  redrawRect();
});

// ----------------- Editing -----------------
function toggleAt(x,y){
  const idx = nearestPoint(x,y,PICK_R);
  if(idx < 0) return;
  pushHistory();
  points[idx].excluded = !points[idx].excluded;
  redrawRect();
}
function addManualAt(x,y){
  pushHistory();
  const dMm = 6.0;
  const r = (dMm/2) / mmPerPx;
  points.push({x,y,r,dMm,src:"manual",excluded:false});
  redrawRect();
}
function startDragAt(x,y){
  const idx = nearestPoint(x,y,PICK_R);
  if(idx < 0) return;
  dragging = true;
  dragIdx = idx;
  pushHistory();
  if(points[dragIdx].src === "auto") points[dragIdx].src = "manual";
}
function moveDragTo(x,y){
  if(!dragging || dragIdx<0) return;
  points[dragIdx].x = x;
  points[dragIdx].y = y;
  redrawRect();
}
function endDrag(){ dragging=false; dragIdx=-1; }

// Desktop
cRect.addEventListener("mousedown", (ev)=>{
  if(!lastWarped) return;
  const p = canvasXY(ev, cRect);
  pressTimer = setTimeout(()=> startDragAt(p.x,p.y), 180);
});
cRect.addEventListener("mousemove", (ev)=>{
  if(!lastWarped) return;
  const p = canvasXY(ev, cRect);
  if(dragging) moveDragTo(p.x,p.y);
});
cRect.addEventListener("mouseup", (ev)=>{
  if(!lastWarped) return;
  clearTimeout(pressTimer);
  const p = canvasXY(ev, cRect);

  if(dragging){
    endDrag();
    redrawRect();
    return;
  }

  const now = Date.now();
  const isDouble = (now - lastTapTime) < 260 && lastTapPos && dist2(lastTapPos, p) < 18*18;
  lastTapTime = now; lastTapPos = p;

  if(isDouble) addManualAt(p.x,p.y);
  else toggleAt(p.x,p.y);
});

// iOS touch
cRect.addEventListener("touchstart", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();

  const t = ev.touches[0];
  const p = canvasXY(t, cRect);

  doubleHandled = false;

  pressTimer = setTimeout(()=> startDragAt(p.x,p.y), 180);

  const now = Date.now();
  const isDouble = (now - lastTapTime) < 260 && lastTapPos && dist2(lastTapPos, p) < 18*18;
  lastTapTime = now; lastTapPos = p;

  if(isDouble){
    doubleHandled = true;
    clearTimeout(pressTimer);
    addManualAt(p.x,p.y);
  }
}, {passive:false});

cRect.addEventListener("touchmove", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();
  const t = ev.touches[0];
  const p = canvasXY(t, cRect);
  if(dragging) moveDragTo(p.x,p.y);
}, {passive:false});

cRect.addEventListener("touchend", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();
  clearTimeout(pressTimer);

  if(dragging){
    endDrag();
    redrawRect();
    return;
  }

  if(!doubleHandled && lastTapPos){
    toggleAt(lastTapPos.x, lastTapPos.y);
  }
}, {passive:false});

// Buttons
undoBtn.addEventListener("click", ()=>{
  if(!history.length) return;
  points = JSON.parse(history.pop());
  redrawRect();
});
clearManualBtn.addEventListener("click", ()=>{
  if(!points.length) return;
  pushHistory();
  points = points.filter(p => p.src !== "manual");
  redrawRect();
});
resetEditsBtn.addEventListener("click", ()=>{
  history = [];
  points = clonePts(basePoints);
  redrawRect();
});
exportBtn.addEventListener("click", ()=>{
  const payload = {
    version: "A2.0_SIMPLE",
    rect_px: RECT,
    frame_mm: FRAME_MM,
    mm_per_px: mmPerPx,
    calib: CALIB,
    min_mm: DMIN_MM,
    detect_max_mm: DMAX_DETECT_MM,
    points: points
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "mwc_a2_0_points.json";
  a.click();
});
savePngBtn.addEventListener("click", ()=>{
  if(!lastWarped) return;
  const a = document.createElement("a");
  a.href = cRect.toDataURL("image/png");
  a.download = "mwc_a2_0_marked.png";
  a.click();
});

// init
updateUI();
</script>
</body>
</html>
