<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC — Auto Growth (Day1 vs Day2)</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:160px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#111;white-space:pre-wrap}
  .ok{color:#0a7;font-weight:800}
  .warn{color:#c90;font-weight:800}
  .bad{color:#c00;font-weight:800}
</style>
</head>

<body>
<h1>MWC — Автоопределение выросших грибов (Day1 → Day2)</h1>
<div class="small">
Загрузи 2 фото (одинаковый ракурс). Нажми <b>Анализ</b> — программа выровняет Day1 под Day2, найдёт зоны роста и отметит <b style="color:#0a7">зелёным</b> на Day2.
</div>

<div class="card">
  <b>Загрузка</b>
  <div class="small">Day1</div>
  <input id="img1" type="file" accept="image/*">
  <div class="small">Day2</div>
  <input id="img2" type="file" accept="image/*">

  <div class="row">
    <button id="show1" class="secondary" disabled>Показать Day1</button>
    <button id="show2" class="secondary" disabled>Показать Day2</button>
  </div>

  <button id="analyze" disabled>Анализ (выросшие → зелёным)</button>
  <div class="kv" id="status">Загрузи оба фото.</div>
</div>

<div class="card">
  <b>Просмотр</b>
  <canvas id="cv"></canvas>
  <div class="small">После анализа: зелёные круги = кандидаты “выросло”.</div>
</div>

<div class="card">
  <div class="row">
    <button id="savepng" class="secondary" disabled>Сохранить PNG</button>
    <button id="export" class="secondary" disabled>Экспорт JSON</button>
  </div>
</div>

<script>
const img1Input = document.getElementById("img1");
const img2Input = document.getElementById("img2");
const show1Btn  = document.getElementById("show1");
const show2Btn  = document.getElementById("show2");
const analyzeBtn= document.getElementById("analyze");
const saveBtn   = document.getElementById("savepng");
const exportBtn = document.getElementById("export");

const statusEl  = document.getElementById("status");
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { willReadFrequently:true });

// images
let day1 = null, day2 = null;
// view mode
let view = 2; // 1 or 2
// results
let result = null; // {dx,dy, thr, blobs:[{x,y,r,area,bbox}], meta...}

function setStatus(t, cls=""){
  statusEl.className = "kv " + cls;
  statusEl.textContent = t;
}
function ready(){ return !!(day1 && day2); }

function fileToImg(f){
  return new Promise((resolve,reject)=>{
    const i = new Image();
    i.onload = ()=>resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function fitCanvasToImage(img){
  const maxW = 1100;
  const sc = Math.min(1, maxW / img.naturalWidth);
  cv.width  = Math.round(img.naturalWidth * sc);
  cv.height = Math.round(img.naturalHeight * sc);
}

function updateUI(){
  const r = ready();
  show1Btn.disabled = !r;
  show2Btn.disabled = !r;
  analyzeBtn.disabled = !r;
  saveBtn.disabled = !r;
  exportBtn.disabled = !result;
}

// draw current view (Day1 or Day2) with overlays
function redraw(){
  if(!ready()) return;

  if(view === 1){
    fitCanvasToImage(day1);
    ctx.drawImage(day1, 0, 0, cv.width, cv.height);
    // optionally show alignment shift if result exists
    if(result){
      ctx.font = "14px ui-monospace, Menlo, monospace";
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(8,8,260,24);
      ctx.fillStyle = "#fff";
      ctx.fillText(`align dx=${result.dx}, dy=${result.dy}`, 14, 26);
    }
  } else {
    fitCanvasToImage(day2);
    ctx.drawImage(day2, 0, 0, cv.width, cv.height);
    if(result){
      drawBlobs(result.blobs);
      ctx.font = "14px ui-monospace, Menlo, monospace";
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(8,8,360,44);
      ctx.fillStyle = "#fff";
      ctx.fillText(`grown candidates: ${result.blobs.length}`, 14, 26);
      ctx.fillText(`align dx=${result.dx}, dy=${result.dy}  thr=${result.thr.toFixed(1)}`, 14, 44);
    }
  }
}

// draw green circles for blobs
function drawBlobs(blobs){
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#00aa55";
  for(const b of blobs){
    ctx.beginPath();
    ctx.arc(b.x, b.y, Math.max(10, b.r), 0, Math.PI*2);
    ctx.stroke();
  }
}

// ------------- ANALYSIS PIPELINE -------------
// 1) downscale both to same size
// 2) estimate translation dx,dy (small range) that best aligns Day1 to Day2
// 3) compute positive difference (Day2 - aligned Day1) in grayscale
// 4) threshold + morphology cleanup
// 5) connected components -> blobs -> filter by size/shape
async function analyze(){
  setStatus("Анализ: подготовка…", "warn");

  // choose common working size based on Day2 rendered size
  const maxW = 900;
  const sc = Math.min(1, maxW / day2.naturalWidth);
  const W = Math.round(day2.naturalWidth * sc);
  const H = Math.round(day2.naturalHeight * sc);

  // offscreen canvases
  const c1 = document.createElement("canvas");
  const c2 = document.createElement("canvas");
  c1.width=W; c1.height=H;
  c2.width=W; c2.height=H;
  const x1 = c1.getContext("2d", {willReadFrequently:true});
  const x2 = c2.getContext("2d", {willReadFrequently:true});

  x1.drawImage(day1, 0, 0, W, H);
  x2.drawImage(day2, 0, 0, W, H);

  const im1 = x1.getImageData(0,0,W,H);
  const im2 = x2.getImageData(0,0,W,H);

  // grayscale arrays
  const g1 = toGray(im1.data, W*H);
  const g2 = toGray(im2.data, W*H);

  setStatus("Анализ: выравнивание (поиск сдвига)…", "warn");
  const {dx,dy,score} = estimateShift(g1,g2,W,H);
  // apply shift to g1 into aligned buffer
  const g1a = shiftGray(g1,W,H,dx,dy);

  setStatus("Анализ: разность и выделение роста…", "warn");
  const diff = new Float32Array(W*H);
  let sum=0, sum2=0;
  for(let i=0;i<diff.length;i++){
    const v = g2[i] - g1a[i]; // positive means brighter/stronger in Day2
    diff[i] = v;
    sum += v;
    sum2 += v*v;
  }
  const mean = sum/diff.length;
  const std = Math.sqrt(Math.max(1e-6, (sum2/diff.length) - mean*mean));

  // threshold: mean + k*std (tuned)
  const thr = mean + 2.2*std;

  // binary mask
  const mask = new Uint8Array(W*H);
  for(let i=0;i<mask.length;i++){
    // also ignore tiny positives near zero
    mask[i] = (diff[i] > thr && diff[i] > 10) ? 1 : 0;
  }

  // morphology: close-open to reduce noise
  morphDilate(mask,W,H,1);
  morphErode(mask,W,H,1);
  morphErode(mask,W,H,1);
  morphDilate(mask,W,H,1);

  setStatus("Анализ: поиск объектов…", "warn");
  const comps = connectedComponents(mask,W,H);

  // filter components into blobs (shape + area)
  const blobs = [];
  for(const c of comps){
    // area thresholds relative to size
    if(c.area < 45) continue;
    if(c.area > W*H*0.02) continue; // too big -> likely lighting change
    const bw = c.maxX - c.minX + 1;
    const bh = c.maxY - c.minY + 1;
    const ar = bw / bh;
    if(ar < 0.35 || ar > 2.8) continue;

    // equivalent radius from area
    const r = Math.sqrt(c.area / Math.PI);
    if(r < 4) continue;
    if(r > Math.min(W,H)*0.12) continue;

    blobs.push({
      x: c.cx,
      y: c.cy,
      r,
      area: c.area,
      bbox: [c.minX,c.minY,c.maxX,c.maxY]
    });
  }

  // map blobs coords to display canvas coords when drawing:
  // our redraw() fits cv to natural image with its own scaling; easiest is:
  // store blobs normalized to [0..1] then convert on draw for current view.
  // But we are drawing on cv where we draw image scaled to fit maxW=1100.
  // We can compute scale factor between working W,H and current cv size each redraw.
  // We'll store blobs in working coordinates and convert in drawBlobsScaled().
  result = {dx,dy,thr,score,W,H, blobs};

  setStatus(
    `Готово.\nСдвиг: dx=${dx}, dy=${dy} (score=${score.toFixed(0)})\nКандидатов выросло: ${blobs.length}`,
    blobs.length ? "ok" : "warn"
  );

  // switch to Day2 view with overlay
  view = 2;
  redraw();
  updateUI();
}

// --- helpers: grayscale ---
function toGray(rgba, n){
  const g = new Float32Array(n);
  for(let i=0;i<n;i++){
    const r = rgba[i*4], gg = rgba[i*4+1], b = rgba[i*4+2];
    g[i] = 0.2126*r + 0.7152*gg + 0.0722*b;
  }
  return g;
}

// --- shift: place src into dst with translation (dx,dy) where positive dx shifts right ---
function shiftGray(src,W,H,dx,dy){
  const dst = new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy = y - dy;
    if(sy < 0 || sy >= H) continue;
    for(let x=0;x<W;x++){
      const sx = x - dx;
      if(sx < 0 || sx >= W) continue;
      dst[y*W + x] = src[sy*W + sx];
    }
  }
  return dst;
}

// --- estimate shift by brute force SAD on gradients (downscaled internally) ---
function estimateShift(g1,g2,W,H){
  // further downscale for speed
  const max = 280;
  const sc = Math.min(1, max / W);
  const w = Math.max(80, Math.round(W*sc));
  const h = Math.max(80, Math.round(H*sc));

  const a = resizeGray(g1,W,H,w,h);
  const b = resizeGray(g2,W,H,w,h);

  // use simple gradient magnitude to be less sensitive to lighting
  const ag = gradMag(a,w,h);
  const bg = gradMag(b,w,h);

  const range = 22; // search in [-range..range] px at downscale
  let best = {dx:0,dy:0,score:Infinity};

  // evaluate SAD on central region
  const x0 = Math.floor(w*0.15), x1 = Math.floor(w*0.85);
  const y0 = Math.floor(h*0.15), y1 = Math.floor(h*0.85);

  for(let dy=-range; dy<=range; dy++){
    for(let dx=-range; dx<=range; dx++){
      let s = 0;
      let cnt = 0;
      for(let y=y0; y<y1; y++){
        const sy = y - dy;
        if(sy < y0 || sy >= y1) continue;
        const row = y*w;
        const srow = sy*w;
        for(let x=x0; x<x1; x++){
          const sx = x - dx;
          if(sx < x0 || sx >= x1) continue;
          const v = bg[row+x] - ag[srow+sx];
          s += Math.abs(v);
          cnt++;
        }
      }
      if(cnt>0){
        const score = s / cnt;
        if(score < best.score) best = {dx,dy,score};
      }
    }
  }

  // scale back dx/dy to original working W/H
  const dxFull = Math.round(best.dx / sc);
  const dyFull = Math.round(best.dy / sc);
  return {dx:dxFull, dy:dyFull, score:best.score};
}

function resizeGray(src,SW,SH,W,H){
  const dst = new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy = (y+0.5)*SH/H - 0.5;
    const y0 = Math.max(0, Math.min(SH-1, Math.floor(sy)));
    for(let x=0;x<W;x++){
      const sx = (x+0.5)*SW/W - 0.5;
      const x0 = Math.max(0, Math.min(SW-1, Math.floor(sx)));
      dst[y*W+x] = src[y0*SW + x0];
    }
  }
  return dst;
}

function gradMag(g,W,H){
  const out = new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i = y*W+x;
      const gx = g[i+1]-g[i-1];
      const gy = g[i+W]-g[i-W];
      out[i] = Math.abs(gx) + Math.abs(gy);
    }
  }
  return out;
}

// --- morphology ---
function morphDilate(mask,W,H,it=1){
  for(let t=0;t<it;t++){
    const src = mask.slice();
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const i=y*W+x;
        let m=0;
        for(let yy=-1;yy<=1;yy++){
          const row=(y+yy)*W;
          for(let xx=-1;xx<=1;xx++){
            if(src[row + (x+xx)]) { m=1; break; }
          }
          if(m) break;
        }
        mask[i]=m;
      }
    }
  }
}
function morphErode(mask,W,H,it=1){
  for(let t=0;t<it;t++){
    const src = mask.slice();
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const i=y*W+x;
        let m=1;
        for(let yy=-1;yy<=1;yy++){
          const row=(y+yy)*W;
          for(let xx=-1;xx<=1;xx++){
            if(!src[row + (x+xx)]) { m=0; break; }
          }
          if(!m) break;
        }
        mask[i]=m;
      }
    }
  }
}

// --- connected components (8-neigh) ---
function connectedComponents(mask,W,H){
  const visited = new Uint8Array(W*H);
  const comps = [];
  const qx = new Int32Array(W*H);
  const qy = new Int32Array(W*H);

  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const idx = y*W+x;
      if(!mask[idx] || visited[idx]) continue;

      // BFS
      let head=0, tail=0;
      qx[tail]=x; qy[tail]=y; tail++;
      visited[idx]=1;

      let area=0, sumX=0, sumY=0;
      let minX=x,maxX=x,minY=y,maxY=y;

      while(head<tail){
        const cx = qx[head];
        const cy = qy[head];
        head++;

        area++;
        sumX += cx;
        sumY += cy;
        if(cx<minX) minX=cx;
        if(cx>maxX) maxX=cx;
        if(cy<minY) minY=cy;
        if(cy>maxY) maxY=cy;

        for(let yy=-1;yy<=1;yy++){
          for(let xx=-1;xx<=1;xx++){
            if(xx===0 && yy===0) continue;
            const nx=cx+xx, ny=cy+yy;
            if(nx<0||ny<0||nx>=W||ny>=H) continue;
            const ni = ny*W+nx;
            if(mask[ni] && !visited[ni]){
              visited[ni]=1;
              qx[tail]=nx; qy[tail]=ny; tail++;
            }
          }
        }
      }

      const cx = sumX/area;
      const cy = sumY/area;
      comps.push({area, cx, cy, minX, minY, maxX, maxY});
    }
  }
  return comps;
}

// -------- UI handlers --------
img1Input.addEventListener("change", async ()=>{
  result = null;
  try{
    day1 = await fileToImg(img1Input.files[0]);
    setStatus("Day1 загружено. Теперь Day2.", "warn");
  }catch(e){
    day1 = null;
    setStatus("Ошибка загрузки Day1.", "bad");
  }
  if(ready()){
    view=2;
    redraw();
    setStatus("Оба фото загружены. Нажми «Анализ».", "ok");
  }
  updateUI();
});

img2Input.addEventListener("change", async ()=>{
  result = null;
  try{
    day2 = await fileToImg(img2Input.files[0]);
    setStatus("Day2 загружено. Теперь Day1.", "warn");
  }catch(e){
    day2 = null;
    setStatus("Ошибка загрузки Day2.", "bad");
  }
  if(ready()){
    view=2;
    redraw();
    setStatus("Оба фото загружены. Нажми «Анализ».", "ok");
  }
  updateUI();
});

show1Btn.addEventListener("click", ()=>{ view=1; redraw(); });
show2Btn.addEventListener("click", ()=>{ view=2; redraw(); });

analyzeBtn.addEventListener("click", async ()=>{
  if(!ready()) return;
  await analyze();
});

saveBtn.addEventListener("click", ()=>{
  if(!ready()) return;
  redraw(); // ensure overlay drawn
  const a = document.createElement("a");
  a.href = cv.toDataURL("image/png");
  a.download = "mwc_growth_day2_marked.png";
  a.click();
});

exportBtn.addEventListener("click", ()=>{
  if(!result) return;
  const payload = {
    version: "MWC_AUTO_GROWTH_v1",
    created_at: new Date().toISOString(),
    dx: result.dx,
    dy: result.dy,
    thr: result.thr,
    work_size: {W: result.W, H: result.H},
    blobs: result.blobs
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "mwc_growth_result.json";
  a.click();
});

updateUI();
</script>
</body>
</html>
