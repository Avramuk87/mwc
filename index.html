<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî A1.6 FINAL PRO v3</title>
<meta name="theme-color" content="#111">
<style>
body{font-family:-apple-system,system-ui,Arial;margin:16px}
h1{font-size:20px;margin:0 0 8px}
.small{font-size:13px;color:#555;margin:6px 0}
.card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
button.secondary{background:#fff;color:#111}
button:disabled{opacity:.45}
input{width:100%;margin:8px 0}
pre{white-space:pre-wrap;margin:0}
canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:manipulation}
.ok{color:#0a7;font-weight:700}
.bad{color:#c00;font-weight:700}
.warn{color:#c90;font-weight:700}
.row{display:flex;gap:10px;flex-wrap:wrap}
.row > button{flex:1;min-width:160px}
</style>
</head>

<body>
<h1>MWC ‚Äî A1.6 FINAL PRO v3</h1>
<div class="small">
üü¢ = –ø–∏–Ω—ã <b>4‚Äì12 –º–º</b> (–≤ —Ä–æ—Å—Ç) ‚Ä¢ üü° = <b>2‚Äì4 –º–º</b> (–º–µ–ª–æ—á—å, –Ω–æ –Ω–µ –º—É—Å–æ—Ä)<br>
–£–≥–ª—ã —Ä–∞–º–∫–∏: <b>–õ–í ‚Üí –ü–í ‚Üí –ü–ù ‚Üí –õ–ù</b>
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <div class="row">
    <button id="pick" class="secondary" disabled>–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞</button>
    <button id="run" disabled>–ê–Ω–∞–ª–∏–∑</button>
  </div>
  <div class="small" id="hint">–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card"><pre id="out">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</pre></div>

<div class="card">
  <b>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ (–≤—ã–±–æ—Ä —É–≥–ª–æ–≤)</b>
  <canvas id="src"></canvas>
  <div class="small">–ü–æ—Ä—è–¥–æ–∫: 1) –õ–í  2) –ü–í  3) –ü–ù  4) –õ–ù</div>
</div>

<div class="card">
  <b>–†–∞—Å–ø—Ä–µ–º–ª—ë–Ω–Ω–∞—è —Ä–∞–º–∫–∞ (800√ó800)</b>
  <canvas id="rect"></canvas>
  <div class="small">üü¢ 4‚Äì12 –º–º ‚Ä¢ üü° 2‚Äì4 –º–º</div>
</div>

<script>
const input = document.getElementById("img");
const pickBtn = document.getElementById("pick");
const runBtn  = document.getElementById("run");
const hint = document.getElementById("hint");
const out  = document.getElementById("out");
const cSrc = document.getElementById("src");
const cRect= document.getElementById("rect");
const srcCtx = cSrc.getContext("2d", { willReadFrequently:true });
const rectCtx= cRect.getContext("2d", { willReadFrequently:true });

let imgObj = null;
let picking = false;
let corners = [];

const RECT = 800;
const FRAME_MM = 200;
const mmPerPx = FRAME_MM / RECT;

function setOut(t, cls=""){ out.className = cls; out.textContent = t; }
function updateUI(){
  pickBtn.disabled = !imgObj;
  runBtn.disabled = !(imgObj && corners.length === 4);
  if (!imgObj) hint.textContent = "–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.";
  else if (corners.length < 4) hint.textContent = "–ù–∞–∂–º–∏ ¬´–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞¬ª –∏ —Ç–∫–Ω–∏ 4 —É–≥–ª–∞.";
  else hint.textContent = "–ì–æ—Ç–æ–≤–æ. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.";
}

input.addEventListener("change", async () => {
  corners = []; picking = false;
  try{
    imgObj = await fileToImg(input.files[0]);
    drawSource();
    setOut("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –í—ã–±–µ—Ä–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏.", "warn");
  }catch(e){
    imgObj = null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "bad");
  }
  updateUI();
});

pickBtn.addEventListener("click", () => {
  corners = []; picking = true;
  setOut("–¢–∫–Ω–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏ (–õ–í‚Üí–ü–í‚Üí–ü–ù‚Üí–õ–ù).", "warn");
  drawSource(); updateUI();
});

cSrc.addEventListener("click", (ev) => {
  if (!picking) return;
  const r = cSrc.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cSrc.width  / r.width);
  const y = (ev.clientY - r.top)  * (cSrc.height / r.height);
  corners.push({x,y});
  drawSource();
  if (corners.length === 4){
    picking = false;
    setOut("–£–≥–ª—ã –≤—ã–±—Ä–∞–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  updateUI();
});

runBtn.addEventListener("click", () => {
  if (!imgObj || corners.length !== 4) return;
  setOut("–†–∞—Å–ø—Ä–µ–º–ª–µ–Ω–∏–µ –∏ –∞–Ω–∞–ª–∏–∑‚Ä¶", "warn");

  const warped = warpToRect(cSrc, corners, RECT, RECT);
  cRect.width = RECT; cRect.height = RECT;
  rectCtx.putImageData(warped, 0, 0);

  const {small, grow} = analyzeRectPRO(warped, RECT, RECT);

  rectCtx.putImageData(warped, 0, 0);
  rectCtx.lineWidth = 3;

  // small (2‚Äì4mm) yellow
  rectCtx.strokeStyle = "#ffd400";
  for (const p of small){
    rectCtx.beginPath();
    rectCtx.arc(p.cx, p.cy, Math.max(5, p.dPx/2), 0, Math.PI*2);
    rectCtx.stroke();
  }

  // grow (4‚Äì12mm) green
  rectCtx.strokeStyle = "#00ff00";
  let sum = 0;
  for (const p of grow){
    sum += p.dMm;
    rectCtx.beginPath();
    rectCtx.arc(p.cx, p.cy, Math.max(6, p.dPx/2), 0, Math.PI*2);
    rectCtx.stroke();
  }

  const avg = grow.length ? (sum/grow.length).toFixed(1) : "0.0";
  setOut(
    `–ü–∏–Ω—ã 2‚Äì4 –º–º (–º–µ–ª–æ—á—å): ${small.length}\n`+
    `–ü–∏–Ω—ã 4‚Äì12 –º–º (–≤ —Ä–æ—Å—Ç): ${grow.length}\n`+
    `–°—Ä–µ–¥–Ω–∏–π –¥–∏–∞–º–µ—Ç—Ä (–≤ —Ä–æ—Å—Ç): ${avg} –º–º\n`+
    `–ú–∞—Å—à—Ç–∞–±: ${mmPerPx.toFixed(4)} –º–º/px`,
    (grow.length>0) ? "ok" : "bad"
  );
});

// ---------- helpers ----------
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}
function drawSource(){
  const maxW = 1100;
  const sc = Math.min(1, maxW / imgObj.naturalWidth);
  const w = Math.round(imgObj.naturalWidth * sc);
  const h = Math.round(imgObj.naturalHeight * sc);
  cSrc.width = w; cSrc.height = h;
  srcCtx.drawImage(imgObj, 0, 0, w, h);

  if (corners.length){
    srcCtx.lineWidth = 4;
    srcCtx.strokeStyle = "#00ff00";
    srcCtx.fillStyle = "#00ff00";
    srcCtx.font = "20px system-ui";
    corners.forEach((p,i)=>{
      srcCtx.beginPath(); srcCtx.arc(p.x,p.y,8,0,Math.PI*2); srcCtx.fill();
      srcCtx.fillText(String(i+1), p.x+10, p.y-10);
    });
    if (corners.length===4){
      srcCtx.beginPath();
      srcCtx.moveTo(corners[0].x,corners[0].y);
      for(let i=1;i<4;i++) srcCtx.lineTo(corners[i].x,corners[i].y);
      srcCtx.closePath(); srcCtx.stroke();
    }
  }
}

// ---------- perspective warp ----------
function warpToRect(sourceCanvas, srcPts, dstW, dstH){
  const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
  const H = computeHomography(dstPts, srcPts);

  const sCtx = sourceCanvas.getContext("2d", { willReadFrequently:true });
  const sW = sourceCanvas.width, sH = sourceCanvas.height;
  const sData = sCtx.getImageData(0,0,sW,sH).data;

  const out = new ImageData(dstW, dstH);
  const o = out.data;

  for(let y=0;y<dstH;y++){
    for(let x=0;x<dstW;x++){
      const [sx, sy] = applyH(H, x, y);
      const ix = Math.floor(sx), iy = Math.floor(sy);
      const di = (y*dstW + x)*4;
      if (ix>=0 && iy>=0 && ix<sW && iy<sH){
        const si = (iy*sW + ix)*4;
        o[di]=sData[si]; o[di+1]=sData[si+1]; o[di+2]=sData[si+2]; o[di+3]=255;
      } else { o[di]=o[di+1]=o[di+2]=0; o[di+3]=255; }
    }
  }
  return out;
}
function applyH(H, x, y){
  const a = H[0]*x + H[1]*y + H[2];
  const b = H[3]*x + H[4]*y + H[5];
  const c = H[6]*x + H[7]*y + H[8];
  return [a/c, b/c];
}
function computeHomography(p, q){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const x=p[i].x, y=p[i].y, u=q[i].x, v=q[i].y;
    A.push([x,y,1,0,0,0,-x*u,-y*u]); b.push(u);
    A.push([0,0,0,x,y,1,-x*v,-y*v]); b.push(v);
  }
  const h = solve8(A,b);
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7],1];
}
function solve8(A,b){
  const n=8, M=A.map((r,i)=>r.concat([b[i]]));
  for(let c=0;c<n;c++){
    let p=c; for(let r=c+1;r<n;r++) if(Math.abs(M[r][c])>Math.abs(M[p][c])) p=r;
    [M[c],M[p]]=[M[p],M[c]];
    const d=M[c][c]||1e-12; for(let j=c;j<=n;j++) M[c][j]/=d;
    for(let r=0;r<n;r++){ if(r===c) continue; const f=M[r][c]; for(let j=c;j<=n;j++) M[r][j]-=f*M[c][j]; }
  }
  return M.map(r=>r[n]);
}

// ---------- analysis (PRO v3 anti-noise) ----------
function analyzeRectPRO(imageData, w, h){
  const d=imageData.data;
  const gray=new Float32Array(w*h);
  for(let i=0;i<w*h;i++) gray[i]=0.2126*d[i*4]+0.7152*d[i*4+1]+0.0722*d[i*4+2];

  const bg = boxBlur(gray,w,h,18);

  const T1 = 12;
  const T2 = 8;        // ‚úÖ back to safer value
  const MIN_AREA = 16;
  const MIN_CIRC = 0.20;

  // hard anti-noise: ignore <2mm completely
  const MIN_MM_NOISE = 2.0;

  let bin1=new Uint8Array(w*h);
  let bin2=new Uint8Array(w*h);
  for(let i=0;i<w*h;i++){
    const v = gray[i]-bg[i];
    bin1[i] = (v > T1) ? 1 : 0;
    bin2[i] = (v > T2) ? 1 : 0;
  }

  bin1 = close(bin1,w,h);
  bin2 = close(bin2,w,h);

  const circles = [];
  for (const c of components(bin1,w,h).concat(components(bin2,w,h))){
    if(c.area < MIN_AREA) continue;
    const circ=(c.per>0)?(4*Math.PI*c.area/(c.per*c.per)):0;
    if(circ < MIN_CIRC) continue;

    const dPx=2*Math.sqrt(c.area/Math.PI);
    const dMm=dPx*mmPerPx;

    if(dMm < MIN_MM_NOISE) continue; // ‚úÖ —É–±—Ä–∞–ª–∏ –º–∏—Ü–µ–ª–∏–π/—à—É–º

    circles.push({cx:c.cx, cy:c.cy, dPx, dMm});
  }

  const merged = mergeClose(circles, 9); // ‚úÖ moderate merge

  const small = [];
  const grow  = [];
  for(const p of merged){
    if(p.dMm >= 2 && p.dMm < 4) small.push(p);
    else if(p.dMm >= 4 && p.dMm <= 12) grow.push(p);
  }
  return {small, grow};
}

function mergeClose(list, distPx){
  const out = [];
  const used = new Uint8Array(list.length);
  for(let i=0;i<list.length;i++){
    if(used[i]) continue;
    let best=list[i];
    used[i]=1;
    for(let j=i+1;j<list.length;j++){
      if(used[j]) continue;
      const dx=list[j].cx-best.cx, dy=list[j].cy-best.cy;
      if(dx*dx+dy*dy <= distPx*distPx){
        used[j]=1;
        if(list[j].dPx > best.dPx) best = list[j];
      }
    }
    out.push(best);
  }
  return out;
}

function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

function dilate(b,w,h){
  const o=new Uint8Array(w*h);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
    const p=y*w+x;
    o[p]=b[p]||b[p-1]||b[p+1]||b[p-w]||b[p+w]||b[p-w-1]||b[p-w+1]||b[p+w-1]||b[p+w+1]?1:0;
  }
  return o;
}
function erode(b,w,h){
  const o=new Uint8Array(w*h);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
    const p=y*w+x;
    o[p]=b[p]&&b[p-1]&&b[p+1]&&b[p-w]&&b[p+w]&&b[p-w-1]&&b[p-w+1]&&b[p+w-1]&&b[p+w+1]?1:0;
  }
  return o;
}
function close(b,w,h){
  let x = erode(dilate(b,w,h),w,h);
  x = dilate(erode(x,w,h),w,h);
  return x;
}

function components(b,w,h){
  const v=new Uint8Array(w*h), st=[], res=[], id=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
    const p=id(x,y);
    if(!b[p]||v[p]) continue;
    let a=0,sx=0,sy=0,per=0;
    st.length=0; st.push(p); v[p]=1;
    while(st.length){
      const q=st.pop(), qy=(q/w)|0, qx=q-qy*w;
      a++; sx+=qx; sy+=qy;
      const n1=q-1,n2=q+1,n3=q-w,n4=q+w;
      if(!b[n1])per++; if(!b[n2])per++; if(!b[n3])per++; if(!b[n4])per++;
      if(b[n1]&&!v[n1]){v[n1]=1;st.push(n1)}
      if(b[n2]&&!v[n2]){v[n2]=1;st.push(n2)}
      if(b[n3]&&!v[n3]){v[n3]=1;st.push(n3)}
      if(b[n4]&&!v[n4]){v[n4]=1;st.push(n4)}
    }
    res.push({area:a,cx:sx/a,cy:sy/a,per});
  }
  return res;
}
</script>
</body>
</html>
