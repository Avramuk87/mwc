<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî B2 Growth (Semi-auto, tuned)</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:150px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#111;white-space:pre-wrap}
  .ok{color:#0a7;font-weight:800}
  .warn{color:#c90;font-weight:800}
  .bad{color:#c00;font-weight:800}
</style>
</head>

<body>
<h1>MWC ‚Äî B2 (–ø–æ–ª—É–∞–≤—Ç–æ): —Ä–æ—Å—Ç Day1‚ÜíDay2</h1>
<div class="small">
–ê–≤—Ç–æ: –Ω–∞—Ö–æ–¥–∏—Ç –≥—Ä–∏–±—ã –Ω–∞ Day2, —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç —Ä–∞–¥–∏—É—Å—ã —Å Day1. –ù–∞ Day2: üü¢ grown, üü° new, üîµ same, üî¥ excluded, üü† manual.<br>
–ü—Ä–∞–≤–∫–∏ Day2: Tap=toggle exclude ‚Ä¢ DoubleTap=add manual ‚Ä¢ Hold+Drag=move
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <div class="small">Day1</div>
  <input id="img1" type="file" accept="image/*">
  <div class="small">Day2</div>
  <input id="img2" type="file" accept="image/*">

  <div class="row">
    <button id="show1" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day1</button>
    <button id="show2" class="secondary" disabled>–ü–æ–∫–∞–∑–∞—Ç—å Day2</button>
  </div>

  <button id="analyze" disabled>–ê–Ω–∞–ª–∏–∑ (–Ω–∞–π—Ç–∏ –≥—Ä–∏–±—ã + —Ä–æ—Å—Ç)</button>
  <div class="kv" id="out">–ó–∞–≥—Ä—É–∑–∏ –æ–±–∞ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card">
  <b>–ü—Ä–æ—Å–º–æ—Ç—Ä</b>
  <canvas id="cv"></canvas>
  <div class="small">–ù–∞ Day2 –º–æ–∂–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫—Ä—É–≥–∏.</div>

  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clearManual" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å manual</button>
    <button id="reset" class="secondary" disabled>–°–±—Ä–æ—Å –ø—Ä–∞–≤–æ–∫</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>

  <div class="small kv">üü¢ grown ‚Ä¢ üü° new ‚Ä¢ üîµ same ‚Ä¢ üî¥ excluded ‚Ä¢ üü† manual</div>
</div>

<script>
/* ------------------- TUNING (–ø–æ–¥ —Ç–≤–æ–∏ —Ñ–æ—Ç–æ) -------------------
   –ï—Å–ª–∏ –≤—Å—ë –µ—â—ë –º–Ω–æ–≥–æ –º–µ–ª–∫–æ–π ‚Äú–ø—ã–ª–∏‚Äù ‚Üí —É–≤–µ–ª–∏—á—å MIN_R_PX –¥–æ 12‚Äì14.
   –ï—Å–ª–∏ –≤—ã—Ä–æ—Å–ª–æ –≤—Å—ë —Ä–∞–≤–Ω–æ 0 ‚Üí —É–º–µ–Ω—å—à–∏ GROW_PX –¥–æ 1.0‚Äì1.5.
---------------------------------------------------------------- */
const WORK_MAX_W = 900;

const DOG_THR = 10.0;       // –±—ã–ª–æ 7.0 (–º–µ–Ω—å—à–µ —à—É–º–∞)
const NMS_MINDIST = 14;     // –±—ã–ª–æ 10 (–º–µ–Ω—å—à–µ –¥—É–±–ª–µ–π)

const MIN_R_PX = 10;        // –æ—Ç—Ä–µ–∑–∞–µ–º –º–∏—Ü–µ–ª–∏–π (–≤–∞–∂–Ω–æ!)
const MAX_R_PX = 110;

const GROW_PX = 1.8;        // –ø–æ—Ä–æ–≥ —Ä–æ—Å—Ç–∞ —Ä–∞–¥–∏—É—Å–∞
const MATCH_MAX_DIST = 18;  // –ø–æ–∏—Å–∫ –Ω–∞ Day1 —Ä—è–¥–æ–º

// –∫—Ä—É–≥–ª—ã–π —Ñ–∏–ª—å—Ç—Ä Day2 (—Å—Ç—Ä–æ–∂–µ)
const CIRC_DAY2 = {
  edgeMeanMin: 12,
  edgeCVMax: 0.60,
  contrastMin: 10
};
// –∫—Ä—É–≥–ª—ã–π —Ñ–∏–ª—å—Ç—Ä Day1 (—á—É—Ç—å –º—è–≥—á–µ, –∏–Ω–∞—á–µ –≤—Å—ë —Å—Ç–∞–Ω–µ—Ç "same" –∏–ª–∏ "new" –∏–∑-–∑–∞ —à—É–º–∞)
const CIRC_DAY1 = {
  edgeMeanMin: 10,
  edgeCVMax: 0.75,
  contrastMin: 8
};

const img1Input = document.getElementById("img1");
const img2Input = document.getElementById("img2");
const show1Btn = document.getElementById("show1");
const show2Btn = document.getElementById("show2");
const analyzeBtn = document.getElementById("analyze");

const outEl = document.getElementById("out");
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { willReadFrequently:true });

const undoBtn = document.getElementById("undo");
const clearManualBtn = document.getElementById("clearManual");
const resetBtn = document.getElementById("reset");
const exportBtn = document.getElementById("export");
const saveBtn = document.getElementById("savepng");

let day1=null, day2=null;
let view=2;

let work=null;
let history=[];
let dragging=false, dragIdx=-1;
let pressTimer=null;
let lastTapTime=0, lastTapPos=null;

let _g2=null, _g1a=null;

function setOut(t, cls=""){
  outEl.className = "kv " + cls;
  outEl.textContent = t;
}
function ready(){ return !!(day1 && day2); }
function updateUI(){
  const r = ready();
  show1Btn.disabled = !r;
  show2Btn.disabled = !r;
  analyzeBtn.disabled = !r;

  undoBtn.disabled = history.length===0;
  clearManualBtn.disabled = !(work && work.blobs2.some(b=>b.src==="manual"));
  resetBtn.disabled = !(work && work.baseBlobs2 && work.baseBlobs2.length);
  exportBtn.disabled = !work;
  saveBtn.disabled = !ready();
}
function pushHistory(){
  if(!work) return;
  history.push(JSON.stringify(work.blobs2));
  if(history.length>120) history.shift();
  updateUI();
}
function invalidateWorkBuffers(){ _g2=null; _g1a=null; }

function fileToImg(f){
  return new Promise((resolve,reject)=>{
    const i=new Image();
    i.onload=()=>resolve(i);
    i.onerror=reject;
    i.src=URL.createObjectURL(f);
  });
}
function fitCanvasToImage(img){
  const maxW=1100;
  const sc=Math.min(1, maxW / img.naturalWidth);
  cv.width=Math.round(img.naturalWidth*sc);
  cv.height=Math.round(img.naturalHeight*sc);
}
function drawBaseImage(){
  if(!ready()) return;
  if(view===1){
    fitCanvasToImage(day1);
    ctx.drawImage(day1,0,0,cv.width,cv.height);
  }else{
    fitCanvasToImage(day2);
    ctx.drawImage(day2,0,0,cv.width,cv.height);
  }
}
function canvasXY(ev){
  const r=cv.getBoundingClientRect();
  const x=(ev.clientX - r.left) * (cv.width / r.width);
  const y=(ev.clientY - r.top)  * (cv.height/ r.height);
  return {x,y};
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function strokeForBlob(b){
  if(b.excluded) return "#ff3333";     // red
  if(b.src==="manual") return "#ff9900"; // orange
  if(b.cls==="grown") return "#00aa55";  // green
  if(b.cls==="new")   return "#ffd400";  // yellow
  return "#2aa8ff"; // same = blue (—á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ –Ω–∞ —Å–≤–µ—Ç–ª–æ–º)
}

function redraw(){
  if(!ready()) return;
  drawBaseImage();

  if(view===2 && work){
    const sx=cv.width/work.W;
    const sy=cv.height/work.H;

    ctx.lineWidth=3;
    for(const b of work.blobs2){
      const x=b.x*sx, y=b.y*sy;
      const r=Math.max(8, b.r*sx);
      ctx.strokeStyle = strokeForBlob(b);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
    }

    const grown = work.blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
    const news  = work.blobs2.filter(b=>!b.excluded && b.cls==="new").length;
    const all   = work.blobs2.filter(b=>!b.excluded).length;

    ctx.font="14px ui-monospace, Menlo, monospace";
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(8,8,520,70);
    ctx.fillStyle="#fff";
    ctx.fillText(`all: ${all}  grown: ${grown}  new: ${news}`, 14, 28);
    ctx.fillText(`align dx=${work.dx}, dy=${work.dy}`, 14, 46);
    ctx.fillText(`kept=${work.meta.kept}  rejected=${work.meta.rejected}`, 14, 64);
  }

  updateUI();
}

/* ---------------- image processing ---------------- */
function toGray(rgba,n){
  const g=new Float32Array(n);
  for(let i=0;i<n;i++){
    const r=rgba[i*4], gg=rgba[i*4+1], b=rgba[i*4+2];
    g[i]=0.2126*r + 0.7152*gg + 0.0722*b;
  }
  return g;
}
function gaussianKernel1D(sigma,r){
  const k=new Float32Array(2*r+1);
  const s2=sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v=Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function gaussianBlurSep(src,w,h,sigma){
  const r=Math.max(1, Math.ceil(sigma*2.5));
  const k=gaussianKernel1D(sigma,r);
  const tmp=new Float32Array(w*h);
  const dst=new Float32Array(w*h);

  for(let y=0;y<h;y++){
    const row=y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx=Math.min(w-1,Math.max(0,x+i));
        sum+=src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy=Math.min(h-1,Math.max(0,y+i));
        sum+=tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

function detectBlobsDoG(g,w,h){
  const bg=boxBlur(g,w,h,18);
  const x=new Float32Array(w*h);
  for(let i=0;i<w*h;i++) x[i]=g[i]-bg[i];

  const rMin=Math.max(MIN_R_PX, 6);
  const rMax=Math.min(80, Math.min(w,h)*0.14);

  const sigmas=[];
  for(let r=rMin; r<=rMax; r*=1.22){
    sigmas.push(r/1.4142);
    if(sigmas.length>18) break;
  }
  const blurs=sigmas.map(s=>gaussianBlurSep(x,w,h,s));

  const cand=[];
  for(let k=0;k<blurs.length-1;k++){
    const a=blurs[k], b=blurs[k+1];
    const dog=new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i]=a[i]-b[i];
    const r=sigmas[k]*1.4142;

    for(let y=1;y<h-1;y++){
      for(let x2=1;x2<w-1;x2++){
        const idx=y*w+x2;
        const v=dog[idx];
        if(v < DOG_THR) continue;
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        cand.push({x:x2,y,score:v,r});
      }
    }
  }

  cand.sort((p,q)=>q.score-p.score);
  const kept=[];
  const minD2=NMS_MINDIST*NMS_MINDIST;

  for(const c of cand){
    if(c.r < MIN_R_PX || c.r > MAX_R_PX) continue;
    let ok=true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minD2){ ok=false; break; }
    }
    if(!ok) continue;
    kept.push({x:c.x,y:c.y,r:c.r,score:c.score});
    if(kept.length>450) break;
  }
  return kept;
}

/* ---- shift estimation (translation) ---- */
function resizeGrayNearest(src,SW,SH,W,H){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy=Math.min(SH-1,Math.max(0,Math.round(y*SH/H)));
    for(let x=0;x<W;x++){
      const sx=Math.min(SW-1,Math.max(0,Math.round(x*SW/W)));
      dst[y*W+x]=src[sy*SW+sx];
    }
  }
  return dst;
}
function gradMag(g,W,H){
  const out=new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i=y*W+x;
      const gx=g[i+1]-g[i-1];
      const gy=g[i+W]-g[i-W];
      out[i]=Math.abs(gx)+Math.abs(gy);
    }
  }
  return out;
}
function estimateShift(g1,g2,W,H){
  const max=260;
  const sc=Math.min(1, max / W);
  const w=Math.max(90,Math.round(W*sc));
  const h=Math.max(90,Math.round(H*sc));

  const a=resizeGrayNearest(g1,W,H,w,h);
  const b=resizeGrayNearest(g2,W,H,w,h);
  const ag=gradMag(a,w,h);
  const bg=gradMag(b,w,h);

  const range=24;
  const x0=Math.floor(w*0.15), x1=Math.floor(w*0.85);
  const y0=Math.floor(h*0.15), y1=Math.floor(h*0.85);

  let best={dx:0,dy:0,score:Infinity};
  for(let dy=-range; dy<=range; dy++){
    for(let dx=-range; dx<=range; dx++){
      let s=0, cnt=0;
      for(let y=y0; y<y1; y++){
        const sy=y-dy;
        if(sy<y0||sy>=y1) continue;
        const row=y*w, srow=sy*w;
        for(let x=x0; x<x1; x++){
          const sx=x-dx;
          if(sx<x0||sx>=x1) continue;
          s+=Math.abs(bg[row+x]-ag[srow+sx]);
          cnt++;
        }
      }
      if(cnt){
        const score=s/cnt;
        if(score<best.score) best={dx,dy,score};
      }
    }
  }
  return {dx:Math.round(best.dx/sc), dy:Math.round(best.dy/sc), score:best.score};
}
function shiftGray(src,W,H,dx,dy){
  const dst=new Float32Array(W*H);
  for(let y=0;y<H;y++){
    const sy=y-dy;
    if(sy<0||sy>=H) continue;
    for(let x=0;x<W;x++){
      const sx=x-dx;
      if(sx<0||sx>=W) continue;
      dst[y*W+x]=src[sy*W+sx];
    }
  }
  return dst;
}

/* ---- radius + circularity ---- */
function estimateRadiusAt(gray,W,H,cx,cy,rMin=MIN_R_PX,rMax=MAX_R_PX){
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return null;

  const N=24;
  let bestR=null, bestS=0;

  for(let r=rMin; r<=rMax; r+=2){
    let s=0, cnt=0;
    for(let k=0;k<N;k++){
      const ang=(k/N)*Math.PI*2;
      const x=x0+Math.cos(ang)*r;
      const y=y0+Math.sin(ang)*r;
      const ix=Math.round(x), iy=Math.round(y);
      if(ix<1||iy<1||ix>=W-1||iy>=H-1) continue;
      const i=iy*W+ix;
      const gx=gray[i+1]-gray[i-1];
      const gy=gray[i+W]-gray[i-W];
      s += Math.abs(gx)+Math.abs(gy);
      cnt++;
    }
    if(cnt){
      const avg=s/cnt;
      if(avg>bestS){ bestS=avg; bestR=r; }
    }
  }
  if(bestR===null) return null;
  if(bestS < 12) return null; // —á—É—Ç—å —Å—Ç—Ä–æ–∂–µ
  return bestR;
}

function circleQuality(gray,W,H,cx,cy,r){
  const N=24;
  const x0=Math.round(cx), y0=Math.round(cy);
  if(x0<2||y0<2||x0>=W-2||y0>=H-2) return {ok:false};

  const rin=Math.max(2, Math.round(r*0.70));
  const rout=Math.max(r+2, Math.round(r*1.15));

  let edgeSum=0, edgeSum2=0, edgeCnt=0;
  let inSum=0,inCnt=0;
  let outSum=0,outCnt=0;

  for(let k=0;k<N;k++){
    const ang=(k/N)*Math.PI*2;
    const cs=Math.cos(ang), sn=Math.sin(ang);

    // edge at r
    {
      const ix=Math.round(x0+cs*r);
      const iy=Math.round(y0+sn*r);
      if(ix<1||iy<1||ix>=W-1||iy>=H-1) continue;
      const i=iy*W+ix;
      const gx=gray[i+1]-gray[i-1];
      const gy=gray[i+W]-gray[i-W];
      const e=Math.abs(gx)+Math.abs(gy);
      edgeSum+=e; edgeSum2+=e*e; edgeCnt++;
    }

    // inside
    {
      const ix=Math.round(x0+cs*rin);
      const iy=Math.round(y0+sn*rin);
      if(ix>=0&&iy>=0&&ix<W&&iy<H){ inSum+=gray[iy*W+ix]; inCnt++; }
    }
    // outside
    {
      const ix=Math.round(x0+cs*rout);
      const iy=Math.round(y0+sn*rout);
      if(ix>=0&&iy>=0&&ix<W&&iy<H){ outSum+=gray[iy*W+ix]; outCnt++; }
    }
  }

  if(edgeCnt<12 || inCnt<12 || outCnt<12) return {ok:false};
  const edgeMean=edgeSum/edgeCnt;
  const edgeStd=Math.sqrt(Math.max(1e-6, edgeSum2/edgeCnt - edgeMean*edgeMean));
  const edgeCV=edgeStd/Math.max(1e-6, edgeMean);
  const contrast=(inSum/inCnt) - (outSum/outCnt);

  return {ok:true, edgeMean, edgeCV, contrast};
}

function passCirc(q, thr){
  if(!q.ok) return false;
  if(q.edgeMean < thr.edgeMeanMin) return false;
  if(q.edgeCV > thr.edgeCVMax) return false;
  if(q.contrast < thr.contrastMin) return false;
  return true;
}

function getWorkGrayDay2(){
  if(_g2) return _g2;
  const W=work.W,H=work.H;
  const c=document.createElement("canvas");
  c.width=W; c.height=H;
  const x=c.getContext("2d",{willReadFrequently:true});
  x.drawImage(day2,0,0,W,H);
  const im=x.getImageData(0,0,W,H);
  _g2=toGray(im.data,W*H);
  return _g2;
}
function getWorkGrayDay1Aligned(){
  if(_g1a) return _g1a;
  const W=work.W,H=work.H;
  const c=document.createElement("canvas");
  c.width=W; c.height=H;
  const x=c.getContext("2d",{willReadFrequently:true});
  x.drawImage(day1,0,0,W,H);
  const im=x.getImageData(0,0,W,H);
  const g1=toGray(im.data,W*H);
  _g1a=shiftGray(g1,W,H,work.dx,work.dy);
  return _g1a;
}

/* ---------------- analyze ---------------- */
async function runAnalyze(){
  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶","warn");

  const sc=Math.min(1, WORK_MAX_W / day2.naturalWidth);
  const W=Math.round(day2.naturalWidth*sc);
  const H=Math.round(day2.naturalHeight*sc);

  const c1=document.createElement("canvas");
  const c2=document.createElement("canvas");
  c1.width=W; c1.height=H;
  c2.width=W; c2.height=H;
  const x1=c1.getContext("2d",{willReadFrequently:true});
  const x2=c2.getContext("2d",{willReadFrequently:true});
  x1.drawImage(day1,0,0,W,H);
  x2.drawImage(day2,0,0,W,H);

  const im1=x1.getImageData(0,0,W,H);
  const im2=x2.getImageData(0,0,W,H);
  const g1=toGray(im1.data,W*H);
  const g2=toGray(im2.data,W*H);

  setOut("–ê–Ω–∞–ª–∏–∑: –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ Day1 ‚Üí Day2‚Ä¶","warn");
  const {dx,dy,score}=estimateShift(g1,g2,W,H);
  const g1a=shiftGray(g1,W,H,dx,dy);

  setOut("–ê–Ω–∞–ª–∏–∑: –ø–æ–∏—Å–∫ –≥—Ä–∏–±–æ–≤ –Ω–∞ Day2‚Ä¶","warn");
  const raw2=detectBlobsDoG(g2,W,H);

  const blobs2=[];
  let rejected=0;

  for(const b of raw2){
    const r2=estimateRadiusAt(g2,W,H,b.x,b.y, MIN_R_PX, MAX_R_PX);
    if(r2===null){ rejected++; continue; }
    if(r2<MIN_R_PX || r2>MAX_R_PX){ rejected++; continue; }

    const q2=circleQuality(g2,W,H,b.x,b.y,r2);
    if(!passCirc(q2, CIRC_DAY2)){ rejected++; continue; }

    blobs2.push({x:b.x,y:b.y,r:r2, src:"auto", excluded:false, cls:"same", match:{found:false,r1:null}});
  }

  setOut("–ê–Ω–∞–ª–∏–∑: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ Day1 vs Day2‚Ä¶","warn");

  for(const b of blobs2){
    let best=null;

    for(let oy=-MATCH_MAX_DIST; oy<=MATCH_MAX_DIST; oy+=3){
      for(let ox=-MATCH_MAX_DIST; ox<=MATCH_MAX_DIST; ox+=3){
        const cx=b.x+ox, cy=b.y+oy;
        if(cx<2||cy<2||cx>=W-2||cy>=H-2) continue;

        const r1=estimateRadiusAt(g1a,W,H,cx,cy, MIN_R_PX, MAX_R_PX);
        if(r1===null) continue;

        const q1=circleQuality(g1a,W,H,cx,cy,r1);
        if(!passCirc(q1, CIRC_DAY1)) continue;

        // score: prefer near center + similar size
        const d2=ox*ox+oy*oy;
        const clos = 1/(1+Math.abs(r1-b.r));
        const score = clos / (1 + d2*0.02);

        if(!best || score>best.score){
          best={r1, score};
        }
      }
    }

    if(!best){
      b.cls="new";
      b.match={found:false,r1:null};
    }else{
      b.match={found:true,r1:best.r1};
      b.cls = (b.r - best.r1) >= GROW_PX ? "grown" : "same";
    }
  }

  work={
    W,H, dx,dy, score,
    blobs2,
    baseBlobs2: JSON.parse(JSON.stringify(blobs2)),
    meta:{sc, kept:blobs2.length, rejected, params:{
      DOG_THR,NMS_MINDIST,MIN_R_PX,MAX_R_PX,GROW_PX,MATCH_MAX_DIST,CIRC_DAY2,CIRC_DAY1
    }}
  };
  history=[];
  invalidateWorkBuffers();
  view=2;

  const grownN=blobs2.filter(b=>!b.excluded && b.cls==="grown").length;
  const newN=blobs2.filter(b=>!b.excluded && b.cls==="new").length;
  const allN=blobs2.filter(b=>!b.excluded).length;

  setOut(
`–ì–æ—Ç–æ–≤–æ.
–°–¥–≤–∏–≥: dx=${dx}, dy=${dy} (score=${score.toFixed(1)})
–ù–∞–π–¥–µ–Ω–æ –≥—Ä–∏–±–æ–≤ (Day2): ${allN}
–í—ã—Ä–æ—Å–ª–æ: ${grownN}
–ù–æ–≤—ã–µ: ${newN}
–û—Ç–±—Ä–∞–∫–æ–≤–∞–Ω–æ: ${rejected}
–ü–æ—Ä–æ–≥ —Ä–æ—Å—Ç–∞: +${GROW_PX}px —Ä–∞–¥–∏—É—Å–∞
MIN_R_PX: ${MIN_R_PX}  DOG_THR: ${DOG_THR}`, "ok");

  redraw();
}

/* --------- Editing Day2 --------- */
function toggleExcludeAt(x,y){
  const idx=nearestBlobIdx(x,y,28);
  if(idx<0) return;
  pushHistory();
  work.blobs2[idx].excluded=!work.blobs2[idx].excluded;
  redraw();
}
function addManualAt(x,y){
  if(!work) return;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const wx=x*sx, wy=y*sy;

  pushHistory();
  const g2=getWorkGrayDay2();
  const g1a=getWorkGrayDay1Aligned();

  let r=estimateRadiusAt(g2,work.W,work.H,wx,wy, MIN_R_PX, MAX_R_PX);
  if(r===null) r=Math.max(18, MIN_R_PX);

  const b={x:wx,y:wy,r, src:"manual", excluded:false, cls:"new", match:{found:false,r1:null}};

  // try classify vs Day1
  const r1=estimateRadiusAt(g1a,work.W,work.H,wx,wy, MIN_R_PX, MAX_R_PX);
  if(r1!==null){
    const q1=circleQuality(g1a,work.W,work.H,wx,wy,r1);
    if(passCirc(q1, CIRC_DAY1)){
      b.match={found:true,r1};
      b.cls=(r-r1)>=GROW_PX ? "grown" : "same";
    }
  }
  work.blobs2.push(b);
  redraw();
}

function nearestBlobIdx(x,y,px=26){
  if(!work || view!==2) return -1;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const wx=x*sx, wy=y*sy;
  const p={x:wx,y:wy};
  const max2=(px*sx)*(px*sx);
  let best=-1, bestD=1e18;
  for(let i=0;i<work.blobs2.length;i++){
    const b=work.blobs2[i];
    const d=dist2(b,p);
    if(d<max2 && d<bestD){ bestD=d; best=i; }
  }
  return best;
}

function startDragAt(x,y){
  const idx=nearestBlobIdx(x,y,32);
  if(idx<0) return false;
  pushHistory();
  dragging=true; dragIdx=idx;
  work.blobs2[idx].src="manual"; // –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ manual —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω–æ –¥–≤–∏–≥–∞–µ–º
  return true;
}
function moveDragTo(x,y){
  if(!dragging||dragIdx<0) return;
  const sx=work.W/cv.width, sy=work.H/cv.height;
  const b=work.blobs2[dragIdx];
  b.x=x*sx; b.y=y*sy;
  redraw();
}
function endDrag(){ dragging=false; dragIdx=-1; }

/* -------- UI wiring -------- */
img1Input.addEventListener("change", async ()=>{
  work=null; history=[]; invalidateWorkBuffers();
  try{ day1=await fileToImg(img1Input.files[0]); setOut("Day1 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day2.","warn"); }
  catch(e){ day1=null; setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day1.","bad"); }
  if(ready()){ view=2; setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.","ok"); }
  redraw(); updateUI();
});
img2Input.addEventListener("change", async ()=>{
  work=null; history=[]; invalidateWorkBuffers();
  try{ day2=await fileToImg(img2Input.files[0]); setOut("Day2 –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏ Day1.","warn"); }
  catch(e){ day2=null; setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Day2.","bad"); }
  if(ready()){ view=2; setOut("–û–±–∞ —Ñ–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.","ok"); }
  redraw(); updateUI();
});

show1Btn.addEventListener("click", ()=>{ view=1; redraw(); });
show2Btn.addEventListener("click", ()=>{ view=2; redraw(); });

analyzeBtn.addEventListener("click", async ()=>{
  if(!ready()) return;
  invalidateWorkBuffers();
  await runAnalyze();
});

undoBtn.addEventListener("click", ()=>{
  if(!history.length||!work) return;
  work.blobs2=JSON.parse(history.pop());
  redraw();
});
clearManualBtn.addEventListener("click", ()=>{
  if(!work) return;
  pushHistory();
  work.blobs2=work.blobs2.filter(b=>b.src!=="manual");
  redraw();
});
resetBtn.addEventListener("click", ()=>{
  if(!work) return;
  history=[];
  work.blobs2=JSON.parse(JSON.stringify(work.baseBlobs2));
  redraw();
});
exportBtn.addEventListener("click", ()=>{
  if(!work) return;
  const payload={
    version:"MWC_B2_TUNED",
    created_at:new Date().toISOString(),
    align:{dx:work.dx,dy:work.dy,score:work.score},
    work_size:{W:work.W,H:work.H},
    meta:work.meta,
    blobs_day2:work.blobs2
  };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="mwc_b2_tuned.json";
  a.click();
});
saveBtn.addEventListener("click", ()=>{
  if(!ready()) return;
  redraw();
  const a=document.createElement("a");
  a.href=cv.toDataURL("image/png");
  a.download = view===2 ? "mwc_day2_marked.png" : "mwc_day1.png";
  a.click();
});

/* --- gestures --- */
cv.addEventListener("mousedown",(ev)=>{
  if(!work||view!==2) return;
  const p=canvasXY(ev);
  pressTimer=setTimeout(()=> startDragAt(p.x,p.y), 180);
});
cv.addEventListener("mousemove",(ev)=>{
  if(!work||view!==2||!dragging) return;
  const p=canvasXY(ev);
  moveDragTo(p.x,p.y);
});
cv.addEventListener("mouseup",(ev)=>{
  if(!work||view!==2) return;
  clearTimeout(pressTimer);
  const p=canvasXY(ev);
  if(dragging){ endDrag(); return; }

  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(isDouble) addManualAt(p.x,p.y);
  else toggleExcludeAt(p.x,p.y);
});

cv.addEventListener("touchstart",(ev)=>{
  if(!work||view!==2) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);

  pressTimer=setTimeout(()=> startDragAt(p.x,p.y), 180);

  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  lastTapTime=now; lastTapPos=p;

  if(isDouble){
    clearTimeout(pressTimer);
    addManualAt(p.x,p.y);
  }
},{passive:false});

cv.addEventListener("touchmove",(ev)=>{
  if(!work||view!==2||!dragging) return;
  ev.preventDefault();
  const t=ev.touches[0];
  const p=canvasXY(t);
  moveDragTo(p.x,p.y);
},{passive:false});

cv.addEventListener("touchend",(ev)=>{
  if(!work||view!==2) return;
  ev.preventDefault();
  clearTimeout(pressTimer);
  if(dragging){ endDrag(); return; }

  const t=ev.changedTouches[0];
  const p=canvasXY(t);
  const now=Date.now();
  const isDouble=(now-lastTapTime)<260 && lastTapPos && dist2(lastTapPos,p)<18*18;
  if(!isDouble) toggleExcludeAt(p.x,p.y);
},{passive:false});

updateUI();
</script>
</body>
</html>
