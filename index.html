<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC — A1</title>
<meta name="theme-color" content="#111111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button:disabled{opacity:.45}
  input{width:100%;margin:8px 0}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px}
  .ok{color:#0a7;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .bad{color:#c00;font-weight:700}
</style>
</head>

<body>
<h1>MWC — A1 (пины &gt;4 мм) — без OpenCV</h1>
<div class="small">
Фото из <b>галереи</b>. Алгоритм: порог по «белому» + поиск пятен (connected components) + фильтр по форме.
</div>

<div class="card">
  <b>Выбери фото</b>
  <input id="img" type="file" accept="image/*">
  <button id="btn" disabled>АНАЛИЗ</button>
  <div class="small" id="hint">Выбери фото — кнопка активируется.</div>
</div>

<div class="card"><pre id="out">Загрузи фото.</pre></div>

<div class="card">
  <canvas id="cv"></canvas>
  <div class="small">Найденные пины &gt;4 мм обведены зелёным.</div>
</div>

<script>
const input = document.getElementById("img");
const btn   = document.getElementById("btn");
const out   = document.getElementById("out");
const hint  = document.getElementById("hint");
const canvas= document.getElementById("cv");

function set(t, cls=""){ out.className = cls; out.textContent = t; }
function hasFile(){ return input.files && input.files[0]; }
function updateUI(){
  btn.disabled = !hasFile();
  hint.textContent = hasFile() ? "Готово. Нажми «АНАЛИЗ»." : "Выбери фото — кнопка активируется.";
}
updateUI();

input.addEventListener("change", () => {
  if (hasFile()) set("Фото выбрано. Нажми «АНАЛИЗ».");
  else set("Загрузи фото.");
  updateUI();
});

function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function drawCircle(ctx, x, y, r){
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.stroke();
}

// Connected components on binary image
function analyzeImage(img){
  // 1) draw & downscale for speed
  const maxSide = 900; // iPhone-friendly
  const w0 = img.naturalWidth, h0 = img.naturalHeight;
  const scale = Math.min(1, maxSide / Math.max(w0, h0));
  const w = Math.max(1, Math.round(w0 * scale));
  const h = Math.max(1, Math.round(h0 * scale));

  const off = document.createElement("canvas");
  off.width = w; off.height = h;
  const octx = off.getContext("2d", { willReadFrequently:true });
  octx.drawImage(img, 0, 0, w, h);

  const id = octx.getImageData(0,0,w,h);
  const data = id.data;

  // 2) build binary mask of "white-ish"
  // Threshold can be tuned. Start with 205.
  const TH = 205;

  const bin = new Uint8Array(w*h);
  for (let y=0; y<h; y++){
    let row = y*w;
    for (let x=0; x<w; x++){
      const i = (row + x)*4;
      const r = data[i], g = data[i+1], b = data[i+2];
      // luminance
      const lum = (r*0.2126 + g*0.7152 + b*0.0722);
      bin[row + x] = (lum >= TH) ? 1 : 0;
    }
  }

  // 3) visited map
  const vis = new Uint8Array(w*h);

  // 4) component scan (flood fill)
  const comps = [];
  const stack = [];

  const idx = (x,y)=>y*w+x;

  // parameters
  const MIN_AREA = 35;         // noise filter (in pixels at scaled size)
  const MIN_CIRC = 0.45;       // 1.0 perfect circle
  // NOTE: mmPerPx is approximate in A1 (we'll calibrate by frame later)
  const mmPerPx = 200 / 800;   // placeholder

  for (let y=1; y<h-1; y++){
    for (let x=1; x<w-1; x++){
      const p = idx(x,y);
      if (!bin[p] || vis[p]) continue;

      // start fill
      let area = 0;
      let sumX = 0, sumY = 0;
      let perimeter = 0;

      stack.length = 0;
      stack.push(p);
      vis[p] = 1;

      while (stack.length){
        const q = stack.pop();
        const qy = Math.floor(q / w);
        const qx = q - qy*w;

        area++;
        sumX += qx;
        sumY += qy;

        // perimeter estimate: count edges touching background
        // 4-neighborhood
        const n1 = q - 1;
        const n2 = q + 1;
        const n3 = q - w;
        const n4 = q + w;

        if (!bin[n1]) perimeter++;
        if (!bin[n2]) perimeter++;
        if (!bin[n3]) perimeter++;
        if (!bin[n4]) perimeter++;

        // push neighbors if white and not visited
        if (bin[n1] && !vis[n1]) { vis[n1]=1; stack.push(n1); }
        if (bin[n2] && !vis[n2]) { vis[n2]=1; stack.push(n2); }
        if (bin[n3] && !vis[n3]) { vis[n3]=1; stack.push(n3); }
        if (bin[n4] && !vis[n4]) { vis[n4]=1; stack.push(n4); }
      }

      if (area < MIN_AREA) continue;

      const cx = sumX / area;
      const cy = sumY / area;

      // circularity
      const circ = (perimeter>0) ? (4*Math.PI*area/(perimeter*perimeter)) : 0;
      if (circ < MIN_CIRC) continue;

      // equivalent diameter (px -> mm)
      const dPx = 2*Math.sqrt(area/Math.PI);
      const dMm = dPx * mmPerPx;

      if (dMm >= 4){
        comps.push({cx, cy, dPx, dMm, circ, area});
      }
    }
  }

  return { w, h, comps, scaleToOriginal: 1/scale };
}

btn.addEventListener("click", async () => {
  if (btn.disabled) return;
  btn.disabled = true;
  set("Анализ…");

  try{
    const img = await fileToImg(input.files[0]);
    const res = analyzeImage(img);

    // draw original scaled image on main canvas
    canvas.width = res.w;
    canvas.height = res.h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, res.w, res.h);

    // draw circles
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#00ff00";

    let sum = 0;
    for (const c of res.comps){
      const r = Math.max(6, c.dPx/2);
      drawCircle(ctx, c.cx, c.cy, r);
      sum += c.dMm;
    }

    const n = res.comps.length;
    const avg = n ? (sum/n).toFixed(1) : "0.0";

    set(`Пинов >4 мм: ${n}\nСредний диаметр: ${avg} мм\n\n(Примечание: мм пока приблизительно. Следующий шаг — автокалибровка по рамке 20×20.)`,
        n ? "ok" : "bad");

  }catch(e){
    set("Ошибка анализа: " + String(e), "bad");
  }finally{
    btn.disabled = !hasFile();
  }
});
</script>
</body>
</html>
