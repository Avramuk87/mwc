<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MWC — A1.7.1 (пины >4 мм)</title>

<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:22px;margin:0 0 6px}
  .small{color:#666;font-size:13px;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:14px;padding:14px;margin:14px 0}
  button{width:100%;padding:14px;border-radius:12px;border:none;background:#000;color:#fff;font-weight:800;font-size:16px}
  button:disabled{opacity:.4}
  canvas{max-width:100%;border-radius:12px;margin-top:12px;border:1px solid #ddd}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
  label{display:block;font-size:13px;color:#333;font-weight:700;margin-top:8px}
  input[type="number"], input[type="range"]{width:100%}
  .ok{color:#0a7;font-weight:800}
  .bad{color:#c00;font-weight:800}
  .warn{color:#c90;font-weight:800}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#333}
</style>
</head>

<body>
<h1>MWC — A1.7.1 (пины &gt;4 мм)</h1>
<div class="small">
Рамка 20×20 см должна быть целиком в кадре. Свет — без бликов по возможности.
</div>

<div class="card">
  <input type="file" id="file" accept="image/*">
  <button id="analyze" disabled>АНАЛИЗ</button>
  <div id="status" class="small">Загрузи фото</div>
</div>

<div class="card">
  <b>Настройки (подкрутка под твой свет)</b>

  <div class="row3">
    <div>
      <label>Порог: blockSize (нечётное 11–51)</label>
      <input id="blockSize" type="number" min="11" max="51" step="2" value="21">
      <div class="small">Больше = мягче к теням, но может ловить мусор</div>
    </div>
    <div>
      <label>Порог: C (чувствительность)</label>
      <input id="Cval" type="number" min="-20" max="20" step="1" value="-5">
      <div class="small">Меньше (например -8) = больше белого (чувствительнее)</div>
    </div>
    <div>
      <label>minArea (отсечь мусор)</label>
      <input id="minArea" type="number" min="5" max="500" step="1" value="35">
      <div class="small">Если ловит мицелий — увеличь (например 60–120)</div>
    </div>
  </div>

  <div class="row3">
    <div>
      <label>minCircularity (форма)</label>
      <input id="minCirc" type="number" min="0.30" max="0.95" step="0.01" value="0.60">
      <div class="small">Если пропускает пины — уменьшай до 0.50</div>
    </div>
    <div>
      <label>Диаметр min, мм</label>
      <input id="dMin" type="number" min="1" max="10" step="0.5" value="4">
    </div>
    <div>
      <label>Диаметр max, мм</label>
      <input id="dMax" type="number" min="6" max="30" step="1" value="12">
      <div class="small">Чтобы не считать грибы — держи 10–14</div>
    </div>
  </div>

  <div class="small">
    Быстрые подсказки:
    <ul>
      <li>Мало находит → C сделай более отрицательным (например -8) и/или minCirc снизь до 0.50</li>
      <li>Много мусора → minArea ↑ (60–150) и/или minCirc ↑ (0.65)</li>
      <li>Считает большие грибы → dMax ↓ (например 10–11)</li>
    </ul>
  </div>
</div>

<div class="card">
  <b>Результат</b>
  <div id="result" class="kv">—</div>
</div>

<div class="card">
  <b>Разметка</b>
  <div class="small">Красным — найденная рамка. Зелёным — засчитанные пины.</div>
  <canvas id="canvas"></canvas>
</div>

<script>
let img = new Image();
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');

const statusEl = document.getElementById('status');
const resEl = document.getElementById('result');
const btn = document.getElementById('analyze');

file.onchange = e => {
  const f = e.target.files[0];
  if(!f) return;
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img,0,0);
    btn.disabled = false;
    statusEl.textContent = "Фото загружено. Нажми «АНАЛИЗ»";
  };
  img.src = URL.createObjectURL(f);
};

function waitCV(){
  return new Promise(r=>{
    let tries=0;
    let t=setInterval(()=>{
      tries++;
      if(window.cv && cv.imread){clearInterval(t);r(true);}
      if(tries>250){clearInterval(t);r(false);} // ~50 сек
    },200);
  });
}

function ensureOdd(n){
  n = Math.max(11, Math.min(51, n|0));
  if(n%2===0) n+=1;
  return n;
}

// Пытаемся найти рамку как 4-угольник максимальной площади
function findFrameQuad(edges, srcW, srcH){
  let contours = new cv.MatVector();
  let hier = new cv.Mat();
  cv.findContours(edges, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let best = null;
  let bestArea = 0;

  for(let i=0;i<contours.size();i++){
    let c = contours.get(i);
    const area = cv.contourArea(c);
    if(area < (srcW*srcH*0.08)) continue; // мелочь

    let peri = cv.arcLength(c, true);
    let approx = new cv.Mat();
    cv.approxPolyDP(c, approx, 0.02*peri, true);

    if(approx.rows === 4){
      // Проверим, что контур выпуклый
      if(!cv.isContourConvex(approx)) { approx.delete(); continue; }

      if(area > bestArea){
        if(best) best.delete();
        best = approx;
        bestArea = area;
      } else {
        approx.delete();
      }
    } else {
      approx.delete();
    }
  }

  contours.delete(); hier.delete();
  return best; // Mat Nx1x2, N=4
}

// упорядочить точки: TL, TR, BR, BL
function orderQuad(quad){
  // quad: Mat 4x1x2
  let pts = [];
  for(let i=0;i<4;i++){
    const p = quad.intPtr(i,0);
    pts.push({x:p[0], y:p[1]});
  }

  // sum and diff method
  pts.sort((a,b)=> (a.x+a.y)-(b.x+b.y));
  const tl = pts[0];
  const br = pts[3];

  const mid = [pts[1], pts[2]];
  mid.sort((a,b)=> (a.x-a.y)-(b.x-b.y)); // diff
  const tr = mid[0];
  const bl = mid[1];

  return [tl,tr,br,bl];
}

// оценка pxPerMM по рамке: берём среднюю длину верх/низ и лево/право
function pxPerMMFromQuad(pts){
  const dist=(a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
  const top = dist(pts[0], pts[1]);
  const bottom = dist(pts[3], pts[2]);
  const left = dist(pts[0], pts[3]);
  const right= dist(pts[1], pts[2]);

  const w = (top+bottom)/2;
  const h = (left+right)/2;

  // рамка 200 мм
  const pxPerMMw = w/200;
  const pxPerMMh = h/200;
  return (pxPerMMw + pxPerMMh)/2;
}

btn.onclick = async ()=>{
  btn.disabled = true;
  statusEl.textContent = "Жду OpenCV…";
  const ok = await waitCV();
  if(!ok){
    statusEl.innerHTML = "<span class='bad'>OpenCV не загрузился. Обнови страницу и попробуй ещё.</span>";
    btn.disabled = false; return;
  }
  statusEl.textContent = "Анализ…";

  // настройки
  const blockSize = ensureOdd(parseInt(document.getElementById('blockSize').value||21,10));
  const C = parseInt(document.getElementById('Cval').value||-5,10);
  const minArea = parseFloat(document.getElementById('minArea').value||35);
  const minCirc = parseFloat(document.getElementById('minCirc').value||0.60);
  const dMin = parseFloat(document.getElementById('dMin').value||4);
  const dMax = parseFloat(document.getElementById('dMax').value||12);

  let src = cv.imread(canvas);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  // edges for frame
  let gblur = new cv.Mat();
  cv.GaussianBlur(gray, gblur, new cv.Size(5,5), 0);

  let edges = new cv.Mat();
  cv.Canny(gblur, edges, 60, 180);

  // find frame quad
  let quad = findFrameQuad(edges, src.cols, src.rows);

  // рисуем исходник
  ctx.drawImage(img,0,0);

  if(!quad){
    resEl.innerHTML = "<span class='bad'>Рамка не найдена.</span>\nПопробуй: меньше бликов, рамка целиком, чуть дальше камера.";
    statusEl.textContent = "Готово";
    // cleanup
    src.delete(); gray.delete(); gblur.delete(); edges.delete();
    btn.disabled = false; return;
  }

  const pts = orderQuad(quad);
  const pxPerMM = pxPerMMFromQuad(pts);

  // draw frame red
  ctx.strokeStyle = "#ff0000";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  ctx.lineTo(pts[1].x, pts[1].y);
  ctx.lineTo(pts[2].x, pts[2].y);
  ctx.lineTo(pts[3].x, pts[3].y);
  ctx.closePath();
  ctx.stroke();

  // adaptive threshold for pins
  let blur = new cv.Mat();
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

  let bin = new cv.Mat();
  cv.adaptiveThreshold(
    blur, bin, 255,
    cv.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv.THRESH_BINARY,
    blockSize, C
  );

  // лёгкая морфология (чтобы убрать дырки и шум)
  let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3,3));
  cv.morphologyEx(bin, bin, cv.MORPH_OPEN, kernel);
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

  let contours = new cv.MatVector();
  let hier = new cv.Mat();
  cv.findContours(bin, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let count=0, sum=0;
  let kept=0, rejected=0;

  for(let i=0;i<contours.size();i++){
    let c = contours.get(i);
    let area = cv.contourArea(c);
    if(area < minArea) { rejected++; continue; }

    let peri = cv.arcLength(c, true);
    if(peri <= 0) { rejected++; continue; }

    let circ = 4*Math.PI*area/(peri*peri);
    if(circ < minCirc) { rejected++; continue; }

    // эквивалентный диаметр
    let dPx = Math.sqrt(4*area/Math.PI);
    let dMM = dPx / pxPerMM;

    if(dMM < dMin || dMM > dMax) { rejected++; continue; }

    // центр масс
    let m = cv.moments(c);
    if(m.m00 === 0) { rejected++; continue; }
    let x = m.m10/m.m00;
    let y = m.m01/m.m00;

    // draw green
    ctx.strokeStyle="#00ff00";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.arc(x, y, Math.max(6, dPx/2), 0, 2*Math.PI);
    ctx.stroke();

    count++; sum += dMM; kept++;
  }

  const avg = count ? (sum/count).toFixed(1) : "0.0";
  const pxmm = pxPerMM.toFixed(3);

  resEl.textContent =
`Пинов > ${dMin} мм: ${count}
Средний диаметр: ${avg} мм
pxPerMM (по рамке): ${pxmm}
Настройки: blockSize=${blockSize}, C=${C}, minArea=${minArea}, minCirc=${minCirc}
kept=${kept}, rejected=${rejected}`;

  statusEl.innerHTML = "<span class='ok'>Готово.</span> Подкрути параметры и повтори «АНАЛИЗ», если нужно.";

  // cleanup
  quad.delete();
  src.delete(); gray.delete(); gblur.delete(); edges.delete();
  blur.delete(); bin.delete(); kernel.delete();
  contours.delete(); hier.delete();

  btn.disabled = false;
};
</script>
</body>
</html>
