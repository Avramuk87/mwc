<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC — A1.5</title>
<meta name="theme-color" content="#111111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button:disabled{opacity:.45}
  input{width:100%;margin:8px 0}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px}
  .ok{color:#0a7;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .bad{color:#c00;font-weight:700}
</style>
</head>

<body>
<h1>MWC — A1.5 (пины &gt;4 мм) — без OpenCV</h1>
<div class="small">
Улучшенный поиск: выравнивание освещения + адаптивный порог + компоненты + фильтр формы.
</div>

<div class="card">
  <b>Выбери фото</b>
  <input id="img" type="file" accept="image/*">
  <button id="btn" disabled>АНАЛИЗ</button>
  <div class="small" id="hint">Выбери фото — кнопка активируется.</div>
</div>

<div class="card"><pre id="out">Загрузи фото.</pre></div>

<div class="card">
  <canvas id="cv"></canvas>
  <div class="small">Зелёным — найденные пины &gt;4 мм.</div>
</div>

<script>
const input = document.getElementById("img");
const btn   = document.getElementById("btn");
const out   = document.getElementById("out");
const hint  = document.getElementById("hint");
const canvas= document.getElementById("cv");

function set(t, cls=""){ out.className = cls; out.textContent = t; }
function hasFile(){ return input.files && input.files[0]; }
function updateUI(){
  btn.disabled = !hasFile();
  hint.textContent = hasFile() ? "Готово. Нажми «АНАЛИЗ»." : "Выбери фото — кнопка активируется.";
}
updateUI();

input.addEventListener("change", () => {
  set(hasFile() ? "Фото выбрано. Нажми «АНАЛИЗ»." : "Загрузи фото.");
  updateUI();
});

function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function drawCircle(ctx, x, y, r){
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
}

// --- Fast box blur using integral image ---
function boxBlurGray(src, w, h, radius){
  const dst = new Float32Array(w*h);
  const r = radius|0;
  const iw = w+1;
  const integ = new Float32Array((w+1)*(h+1));

  // build integral
  for(let y=1;y<=h;y++){
    let rowsum = 0;
    for(let x=1;x<=w;x++){
      rowsum += src[(y-1)*w + (x-1)];
      integ[y*iw + x] = integ[(y-1)*iw + x] + rowsum;
    }
  }

  for(let y=0;y<h;y++){
    const y0 = Math.max(0, y-r), y1 = Math.min(h-1, y+r);
    for(let x=0;x<w;x++){
      const x0 = Math.max(0, x-r), x1 = Math.min(w-1, x+r);
      const A = integ[y0*iw + x0];
      const B = integ[y0*iw + (x1+1)];
      const C = integ[(y1+1)*iw + x0];
      const D = integ[(y1+1)*iw + (x1+1)];
      const area = (x1-x0+1)*(y1-y0+1);
      dst[y*w + x] = (D - B - C + A) / area;
    }
  }
  return dst;
}

// simple morphology on binary: 1 pass dilate then erode (closing)
function dilate(bin,w,h){
  const out = new Uint8Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const p=y*w+x;
      const v = bin[p]||bin[p-1]||bin[p+1]||bin[p-w]||bin[p+w]||bin[p-w-1]||bin[p-w+1]||bin[p+w-1]||bin[p+w+1];
      out[p]=v?1:0;
    }
  }
  return out;
}
function erode(bin,w,h){
  const out = new Uint8Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const p=y*w+x;
      const v = bin[p]&&bin[p-1]&&bin[p+1]&&bin[p-w]&&bin[p+w]&&bin[p-w-1]&&bin[p-w+1]&&bin[p+w-1]&&bin[p+w+1];
      out[p]=v?1:0;
    }
  }
  return out;
}

// Connected components on binary
function connectedComponents(bin,w,h){
  const vis = new Uint8Array(w*h);
  const stack = [];
  const comps = [];

  const idx=(x,y)=>y*w+x;

  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const p = idx(x,y);
      if(!bin[p]||vis[p]) continue;

      let area=0,sumX=0,sumY=0,per=0;
      stack.length=0;
      stack.push(p); vis[p]=1;

      while(stack.length){
        const q=stack.pop();
        const qy=(q/w)|0;
        const qx=q-qy*w;

        area++; sumX+=qx; sumY+=qy;

        const n1=q-1,n2=q+1,n3=q-w,n4=q+w;
        if(!bin[n1]) per++;
        if(!bin[n2]) per++;
        if(!bin[n3]) per++;
        if(!bin[n4]) per++;

        if(bin[n1]&&!vis[n1]){vis[n1]=1;stack.push(n1);}
        if(bin[n2]&&!vis[n2]){vis[n2]=1;stack.push(n2);}
        if(bin[n3]&&!vis[n3]){vis[n3]=1;stack.push(n3);}
        if(bin[n4]&&!vis[n4]){vis[n4]=1;stack.push(n4);}
      }

      const cx=sumX/area, cy=sumY/area;
      comps.push({area,cx,cy,per});
    }
  }
  return comps;
}

function analyze(img){
  // downscale for speed
  const maxSide = 1000;
  const w0=img.naturalWidth, h0=img.naturalHeight;
  const sc = Math.min(1, maxSide/Math.max(w0,h0));
  const w=Math.max(1,Math.round(w0*sc));
  const h=Math.max(1,Math.round(h0*sc));

  const off=document.createElement("canvas");
  off.width=w; off.height=h;
  const ctx=off.getContext("2d",{willReadFrequently:true});
  ctx.drawImage(img,0,0,w,h);
  const id=ctx.getImageData(0,0,w,h);
  const d=id.data;

  // grayscale
  const gray=new Float32Array(w*h);
  for(let i=0;i<w*h;i++){
    const r=d[i*4], g=d[i*4+1], b=d[i*4+2];
    gray[i]=0.2126*r+0.7152*g+0.0722*b;
  }

  // --- PARAMETERS (можно крутить) ---
  const bgRadius = 18;     // радиус для оценки фона (освещение)
  const thrOffset = 18;    // насколько ярче фона должен быть пиксель
  const minArea = 18;      // минимальная площадь компоненты (после downscale)
  const minCirc = 0.28;    // минимальная "круглость"
  const mmPerPx = 200/800; // пока приблизительно (калибровку сделаем позже)
  // ----------------------------------

  // background (box blur)
  const bg = boxBlurGray(gray,w,h,bgRadius);

  // binarize by local contrast: gray > bg + offset
  let bin=new Uint8Array(w*h);
  for(let i=0;i<w*h;i++){
    bin[i] = (gray[i] > bg[i] + thrOffset) ? 1 : 0;
  }

  // close to fill small holes
  bin = erode(dilate(bin,w,h),w,h);

  // components
  const comps = connectedComponents(bin,w,h);

  // filter and measure
  const pins=[];
  for(const c of comps){
    if(c.area < minArea) continue;
    const circ = (c.per>0) ? (4*Math.PI*c.area/(c.per*c.per)) : 0;
    if(circ < minCirc) continue;

    const dPx = 2*Math.sqrt(c.area/Math.PI);
    const dMm = dPx * mmPerPx;

    if(dMm >= 4){
      pins.push({cx:c.cx, cy:c.cy, dPx, dMm, circ, area:c.area});
    }
  }

  return {w,h,sc,pins};
}

btn.addEventListener("click", async () => {
  if(btn.disabled) return;
  btn.disabled=true;
  set("Анализ…");
  try{
    const img = await fileToImg(input.files[0]);
    const res = analyze(img);

    // draw image
    canvas.width=res.w;
    canvas.height=res.h;
    const ctx=canvas.getContext("2d");
    ctx.drawImage(img,0,0,res.w,res.h);

    ctx.lineWidth=3;
    ctx.strokeStyle="#00ff00";

    let sum=0;
    for(const p of res.pins){
      const r=Math.max(6,p.dPx/2);
      drawCircle(ctx,p.cx,p.cy,r);
      sum += p.dMm;
    }

    const n=res.pins.length;
    const avg=n?(sum/n).toFixed(1):"0.0";
    set(`Пинов >4 мм: ${n}\nСредний диаметр: ${avg} мм\n\n(мм пока приблизительно. Следующий шаг — точная калибровка по рамке 20×20.)`,
        n ? "ok" : "bad");
  }catch(e){
    set("Ошибка: "+String(e),"bad");
  }finally{
    btn.disabled=!hasFile();
  }
});
</script>
</body>
</html>
