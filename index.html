<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî A1.8 (‚â•4 –º–º) DoG + Edit</title>
<meta name="theme-color" content="#111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button.secondary{background:#fff;color:#111}
  button:disabled{opacity:.45}
  input[type="file"]{width:100%;margin:8px 0}
  input[type="range"]{width:100%}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:none}
  .ok{color:#0a7;font-weight:700}
  .bad{color:#c00;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row > button{flex:1;min-width:160px}
  .kv{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#333}
</style>
</head>

<body>
<h1>MWC ‚Äî A1.8 (DoG + –ø–æ–ª–∑—É–Ω–æ–∫ + –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞) ‚Äî —Å—á–∏—Ç–∞–µ–º ‚â•4 –º–º</h1>
<div class="small">
–ú–µ—Ç–æ–¥: DoG blob detection (—É—Å—Ç–æ–π—á–∏–≤ –∫ —Ç–µ–∫—Å—Ç—É—Ä–µ/–º–∏—Ü–µ–ª–∏—é).<br>
–£–≥–ª—ã —Ä–∞–º–∫–∏: <b>–õ–í ‚Üí –ü–í ‚Üí –ü–ù ‚Üí –õ–ù</b>. –°—á–∏—Ç–∞–µ–º <b>–≤—Å–µ –≥—Ä–∏–±—ã ‚â• 4 –º–º</b> (–≤–∫–ª—é—á–∞—è –∫—Ä—É–ø–Ω—ã–µ).<br>
<b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:</b> Tap=toggle ‚Ä¢ DoubleTap=add ‚Ä¢ Hold+Drag=move
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <div class="row">
    <button id="pick" class="secondary" disabled>–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞</button>
    <button id="run" disabled>–ê–Ω–∞–ª–∏–∑</button>
  </div>

  <label class="small"><b>Sensitivity</b> (–º–µ–Ω—å—à–µ = —Å—Ç—Ä–æ–∂–µ, –±–æ–ª—å—à–µ = –±–æ–ª—å—à–µ –Ω–∞—Ö–æ–¥–æ–∫)</label>
  <input id="sens" type="range" min="1" max="20" value="8">
  <div class="small kv" id="sensVal">8</div>

  <label class="small"><b>Min size</b> (–º–º) ‚Äî –Ω–∏–∂–Ω–∏–π –ø–æ—Ä–æ–≥ –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞</label>
  <input id="minmm" type="range" min="3" max="10" value="4" step="0.5">
  <div class="small kv" id="minmmVal">4.0</div>

  <div class="small" id="hint">–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card"><pre id="out">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</pre></div>

<div class="card">
  <b>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ (–≤—ã–±–æ—Ä —É–≥–ª–æ–≤)</b>
  <canvas id="src"></canvas>
  <div class="small">–ü–æ—Ä—è–¥–æ–∫: 1) –õ–í  2) –ü–í  3) –ü–ù  4) –õ–ù</div>
</div>

<div class="card">
  <b>–†–∞—Å–ø—Ä–µ–º–ª—ë–Ω–Ω–∞—è —Ä–∞–º–∫–∞ (800√ó800)</b>
  <canvas id="rect"></canvas>
  <div class="row">
    <button id="undo" class="secondary" disabled>Undo</button>
    <button id="clearManual" class="secondary" disabled>–û—á–∏—Å—Ç–∏—Ç—å manual</button>
    <button id="resetEdits" class="secondary" disabled>–°–±—Ä–æ—Å –ø—Ä–∞–≤–æ–∫</button>
  </div>
  <div class="row">
    <button id="export" class="secondary" disabled>–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
    <button id="savepng" class="secondary" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
  </div>
  <div class="small kv" id="editHint">Tap=toggle ‚Ä¢ DoubleTap=add ‚Ä¢ Hold+Drag=move</div>
  <div class="small">üü¢ auto ‚Ä¢ üü° manual ‚Ä¢ üî¥ excluded</div>
</div>

<script>
// ----------------- DOM -----------------
const input = document.getElementById("img");
const pickBtn = document.getElementById("pick");
const runBtn  = document.getElementById("run");
const hint = document.getElementById("hint");
const out  = document.getElementById("out");

const cSrc = document.getElementById("src");
const cRect= document.getElementById("rect");
const srcCtx = cSrc.getContext("2d", { willReadFrequently:true });
const rectCtx= cRect.getContext("2d", { willReadFrequently:true });

const sens = document.getElementById("sens");
const sensVal = document.getElementById("sensVal");

const minmm = document.getElementById("minmm");
const minmmVal = document.getElementById("minmmVal");

const undoBtn = document.getElementById("undo");
const clearManualBtn = document.getElementById("clearManual");
const resetEditsBtn = document.getElementById("resetEdits");
const exportBtn = document.getElementById("export");
const savePngBtn = document.getElementById("savepng");

sens.addEventListener("input", ()=> sensVal.textContent = sens.value);
minmm.addEventListener("input", ()=> {
  minmmVal.textContent = Number(minmm.value).toFixed(1);
  // –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å —Ç–æ—á–∫–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Ä–∏—Å—É–µ–º –∏ –ø–µ—Ä–µ—Å—á–∏—Ç–∞–µ–º (–±–µ–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ DoG)
  if(lastWarped) redrawRect();
});

// ----------------- State -----------------
let imgObj = null;
let picking = false;
let corners = [];

let points = [];        // (auto + manual) + excluded
let basePoints = [];    // —á–∏—Å—Ç—ã–π DoG
let history = [];       // undo
let lastWarped = null;  // ImageData –¥–ª—è redraw

// ----------------- Constants -----------------
const RECT = 800;
const FRAME_MM = 200;
const mmPerPx = FRAME_MM / RECT; // 0.25 –º–º/px

// –ù–∏–∂–Ω–∏–π –ø–æ—Ä–æ–≥ –±–µ—Ä—ë–º –∏–∑ –ø–æ–ª–∑—É–Ω–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 4 –º–º)
function DMIN_MM(){ return Number(minmm.value); }

// –í–µ—Ä—Ö–Ω–∏–π ‚Äú–ø–æ—Ç–æ–ª–æ–∫‚Äù –¥–ª—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ (—á—Ç–æ–±—ã DoG –Ω–µ –ª–æ–≤–∏–ª –æ–≥—Ä–æ–º–Ω—ã–µ –ø—è—Ç–Ω–∞ —Ñ–æ–Ω–∞).
// –≠—Ç–æ –ù–ï –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –º—ã ‚Äú–Ω–µ —Å—á–∏—Ç–∞–µ–º –±–æ–ª—å—à–∏–µ‚Äù: –ø—Ä–æ—Å—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–± –∞–Ω–∞–ª–∏–∑–∞.
const DMAX_DETECT_MM = 60.0; // –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ ‚Äî —Å–∫–∞–∂–µ—à—å (80/100)

// –ü–µ—Ä–µ–≤–æ–¥—ã –º–º <-> px
function rpxFromMm(dmm){ return (dmm/2) / mmPerPx; }

function setOut(t, cls=""){ out.className = cls; out.textContent = t; }

function updateUI(){
  pickBtn.disabled = !imgObj;
  runBtn.disabled = !(imgObj && corners.length === 4);
  savePngBtn.disabled = !lastWarped;
  exportBtn.disabled = points.length === 0;

  if (!imgObj) hint.textContent = "–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.";
  else if (corners.length < 4) hint.textContent = "–ù–∞–∂–º–∏ ¬´–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞¬ª –∏ —Ç–∫–Ω–∏ 4 —É–≥–ª–∞.";
  else hint.textContent = "–ì–æ—Ç–æ–≤–æ. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.";
}

// ----------------- Edit helpers -----------------
function clonePts(arr){ return arr.map(p => ({...p})); }

function pushHistory(){
  history.push(JSON.stringify(points));
  if(history.length > 80) history.shift();
  undoBtn.disabled = history.length === 0;
}

function setPoints(newPts){
  points = newPts;
  undoBtn.disabled = history.length === 0;
  clearManualBtn.disabled = points.filter(p=>p.src==="manual").length === 0;
  resetEditsBtn.disabled = basePoints.length === 0;
  exportBtn.disabled = points.length === 0;
  savePngBtn.disabled = !lastWarped;
}

function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function nearestPoint(x,y, maxPx=28){
  let best = null;
  const p0 = {x,y};
  const max2 = maxPx*maxPx;
  for(let i=0;i<points.length;i++){
    const p = points[i];
    const d = dist2(p, p0);
    if(d <= max2 && (!best || d < best.d2)) best = {i, d2:d};
  }
  return best ? best.i : -1;
}

function canvasXY(ev, canvas){
  const r = canvas.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (canvas.width  / r.width);
  const y = (ev.clientY - r.top)  * (canvas.height / r.height);
  return {x,y};
}

// ----------------- Counting & classes -----------------
function classify(dMm){
  if(dMm < 4) return "<4";
  if(dMm < 6) return "4‚Äì6";
  if(dMm < 10) return "6‚Äì10";
  if(dMm < 20) return "10‚Äì20";
  return "20+";
}

function stats(){
  const min = DMIN_MM();
  let n=0, sum=0;
  let buckets = {"4‚Äì6":0,"6‚Äì10":0,"10‚Äì20":0,"20+":0};

  for(const p of points){
    if(p.excluded) continue;
    if(p.dMm < min) continue;
    n++; sum += p.dMm;
    const cls = classify(p.dMm);
    if(buckets[cls] != null) buckets[cls] += 1;
  }
  return { n, avg: n? (sum/n):0, buckets };
}

// ----------------- Redraw -----------------
function redrawRect(){
  if(!lastWarped) return;
  rectCtx.putImageData(lastWarped, 0, 0);

  for(const p of points){
    // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ (–∏ –º–∞–ª–µ–Ω—å–∫–∏–µ —Ç–æ–∂–µ), –Ω–æ –∫—Ä–∞—Å–∏–º/—Å—á–∏—Ç–∞–µ–º –ø–æ –ø–æ—Ä–æ–≥—É
    const active = !p.excluded;
    const isManual = p.src === "manual";

    rectCtx.lineWidth = 3;
    if(!active) rectCtx.strokeStyle = "#ff3333";
    else if(isManual) rectCtx.strokeStyle = "#ffd400";
    else rectCtx.strokeStyle = "#00ff00";

    rectCtx.beginPath();
    rectCtx.arc(p.x, p.y, Math.max(6, p.r), 0, Math.PI*2);
    rectCtx.stroke();
  }

  const s = parseInt(sens.value,10);
  const st = stats();
  const min = DMIN_MM().toFixed(1);

  setOut(
`–ì—Ä–∏–±—ã ‚â• ${min} –º–º: ${st.n}
–°—Ä–µ–¥–Ω–∏–π –¥–∏–∞–º–µ—Ç—Ä: ${st.avg.toFixed(1)} –º–º
–ö–ª–∞—Å—Å—ã: 4‚Äì6=${st.buckets["4‚Äì6"]}, 6‚Äì10=${st.buckets["6‚Äì10"]}, 10‚Äì20=${st.buckets["10‚Äì20"]}, 20+=${st.buckets["20+"]}
Sensitivity: ${s}
–ú–∞—Å—à—Ç–∞–±: ${mmPerPx.toFixed(4)} –º–º/px
–ü—Ä–∞–≤–∫–∏: manual=${points.filter(p=>p.src==="manual").length}, excluded=${points.filter(p=>p.excluded).length}`,
      st.n ? "ok" : "bad"
  );

  updateUI();
}

// ----------------- Image helpers -----------------
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function drawSource(){
  const maxW = 1100;
  const sc = Math.min(1, maxW / imgObj.naturalWidth);
  const w = Math.round(imgObj.naturalWidth * sc);
  const h = Math.round(imgObj.naturalHeight * sc);
  cSrc.width = w; cSrc.height = h;
  srcCtx.drawImage(imgObj, 0, 0, w, h);

  if (corners.length){
    srcCtx.lineWidth = 4;
    srcCtx.strokeStyle = "#00ff00";
    srcCtx.fillStyle = "#00ff00";
    srcCtx.font = "20px system-ui";
    corners.forEach((p,i)=>{
      srcCtx.beginPath(); srcCtx.arc(p.x,p.y,8,0,Math.PI*2); srcCtx.fill();
      srcCtx.fillText(String(i+1), p.x+10, p.y-10);
    });
    if (corners.length===4){
      srcCtx.beginPath();
      srcCtx.moveTo(corners[0].x,corners[0].y);
      for(let i=1;i<4;i++) srcCtx.lineTo(corners[i].x,corners[i].y);
      srcCtx.closePath(); srcCtx.stroke();
    }
  }
}

// ----------------- Perspective warp -----------------
function warpToRect(sourceCanvas, srcPts, dstW, dstH){
  const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
  const H = computeHomography(dstPts, srcPts);

  const sCtx = sourceCanvas.getContext("2d", { willReadFrequently:true });
  const sW = sourceCanvas.width, sH = sourceCanvas.height;
  const sData = sCtx.getImageData(0,0,sW,sH).data;

  const out = new ImageData(dstW, dstH);
  const o = out.data;

  for(let y=0;y<dstH;y++){
    for(let x=0;x<dstW;x++){
      const [sx, sy] = applyH(H, x, y);
      const ix = Math.floor(sx), iy = Math.floor(sy);
      const di = (y*dstW + x)*4;
      if (ix>=0 && iy>=0 && ix<sW && iy<sH){
        const si = (iy*sW + ix)*4;
        o[di]=sData[si]; o[di+1]=sData[si+1]; o[di+2]=sData[si+2]; o[di+3]=255;
      } else { o[di]=o[di+1]=o[di+2]=0; o[di+3]=255; }
    }
  }
  return out;
}
function applyH(H, x, y){
  const a = H[0]*x + H[1]*y + H[2];
  const b = H[3]*x + H[4]*y + H[5];
  const c = H[6]*x + H[7]*y + H[8];
  return [a/c, b/c];
}
function computeHomography(p, q){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const x=p[i].x, y=p[i].y, u=q[i].x, v=q[i].y;
    A.push([x,y,1,0,0,0,-x*u,-y*u]); b.push(u);
    A.push([0,0,0,x,y,1,-x*v,-y*v]); b.push(v);
  }
  const h = solve8(A,b);
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7],1];
}
function solve8(A,b){
  const n=8, M=A.map((r,i)=>r.concat([b[i]]));
  for(let c=0;c<n;c++){
    let p=c; for(let r=c+1;r<n;r++) if(Math.abs(M[r][c])>Math.abs(M[p][c])) p=r;
    [M[c],M[p]]=[M[p],M[c]];
    const d=M[c][c]||1e-12; for(let j=c;j<=n;j++) M[c][j]/=d;
    for(let r=0;r<n;r++){ if(r===c) continue; const f=M[r][c]; for(let j=c;j<=n;j++) M[r][j]-=f*M[c][j]; }
  }
  return M.map(r=>r[n]);
}

// ----------------- DoG blob detection (multi-scale) -----------------
function detectBlobsDoG(imageData, w, h, sensitivity){
  // sensitivity 1..20 -> lower = stricter, higher = more detections
  const thr = 18 - sensitivity*0.7; // ~17.3 .. ~4
  const thr2 = Math.max(3, thr);

  // grayscale float
  const d = imageData.data;
  const g = new Float32Array(w*h);
  for(let i=0;i<w*h;i++){
    g[i] = 0.2126*d[i*4] + 0.7152*d[i*4+1] + 0.0722*d[i*4+2];
  }

  // remove slow background (helps with mycelium texture)
  const bg = boxBlur(g,w,h,18);
  for(let i=0;i<w*h;i++) g[i] = g[i] - bg[i];

  // scales: from >=4mm up to detect ceiling (DMAX_DETECT_MM)
  const RMIN = rpxFromMm(Math.max(3.5, DMIN_MM()));   // —á—É—Ç—å –Ω–∏–∂–µ –ø–æ—Ä–æ–≥–∞, —á—Ç–æ–±—ã –Ω–µ ‚Äú—Ä—É–±–∏–ª–æ‚Äù –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ
  const RMAX = rpxFromMm(DMAX_DETECT_MM);

  const sigmas = [];
  for(let r=RMIN; r<=RMAX; r*=1.22){
    sigmas.push(r/1.4142);
    if(sigmas.length > 18) break; // safety
  }

  const blurs = sigmas.map(s => gaussianBlurSep(g,w,h,s));

  const candidates = [];
  for(let k=0;k<blurs.length-1;k++){
    const a = blurs[k], b2 = blurs[k+1];
    const dog = new Float32Array(w*h);
    for(let i=0;i<w*h;i++) dog[i] = a[i] - b2[i];

    const r = sigmas[k]*1.4142;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const idx = y*w + x;
        const v = dog[idx];
        if(v < thr2) continue;
        // local max in 3x3
        if(v < dog[idx-1] || v < dog[idx+1] || v < dog[idx-w] || v < dog[idx+w]) continue;
        if(v < dog[idx-w-1] || v < dog[idx-w+1] || v < dog[idx+w-1] || v < dog[idx+w+1]) continue;
        candidates.push({x,y,score:v,r});
      }
    }
  }

  // sort + NMS
  candidates.sort((p,q)=>q.score-p.score);
  const kept = [];
  const minDist = 10;
  const minDist2 = minDist*minDist;

  for(const c of candidates){
    let ok = true;
    for(const k of kept){
      const dx=c.x-k.x, dy=c.y-k.y;
      if(dx*dx+dy*dy < minDist2){ ok=false; break; }
    }
    if(!ok) continue;

    const dMm = (2*c.r) * mmPerPx;

    // –∑–¥–µ—Å—å –ù–ï –æ—Ç—Å–µ–∫–∞–µ–º –∫—Ä—É–ø–Ω—ã–µ —Å–≤–µ—Ä—Ö—É ‚Äî —Ç–æ–ª—å–∫–æ sanity –ø–æ –¥–µ—Ç–µ–∫—Ç-–ø–æ—Ç–æ–ª–∫—É
    // –∞ —Ñ–∏–ª—å—Ç—Ä –ø–æ "—Å—á–∏—Ç–∞–µ–º ‚â• minmm" –¥–µ–ª–∞–µ—Ç—Å—è –≤ stats()/output
    if(dMm < 2.5) continue;
    if(dMm > (DMAX_DETECT_MM + 5)) continue;

    kept.push({ x:c.x, y:c.y, r:c.r, dMm });
    if(kept.length > 420) break; // safety
  }

  return kept;
}

// ----------------- Blurs -----------------
function gaussianBlurSep(src,w,h,sigma){
  const r = Math.max(1, Math.ceil(sigma*2.5));
  const k = gaussianKernel1D(sigma, r);
  const tmp = new Float32Array(w*h);
  const dst = new Float32Array(w*h);

  // horizontal
  for(let y=0;y<h;y++){
    const row = y*w;
    for(let x=0;x<w;x++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const xx = Math.min(w-1, Math.max(0, x+i));
        sum += src[row+xx]*k[i+r];
      }
      tmp[row+x]=sum;
    }
  }
  // vertical
  for(let x=0;x<w;x++){
    for(let y=0;y<h;y++){
      let sum=0;
      for(let i=-r;i<=r;i++){
        const yy = Math.min(h-1, Math.max(0, y+i));
        sum += tmp[yy*w+x]*k[i+r];
      }
      dst[y*w+x]=sum;
    }
  }
  return dst;
}
function gaussianKernel1D(sigma, r){
  const k = new Float32Array(2*r+1);
  const s2 = sigma*sigma*2;
  let sum=0;
  for(let i=-r;i<=r;i++){
    const v = Math.exp(-(i*i)/s2);
    k[i+r]=v; sum+=v;
  }
  for(let i=0;i<k.length;i++) k[i]/=sum;
  return k;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){
    let s=0;
    for(let x=1;x<=w;x++){
      s+=src[(y-1)*w+(x-1)];
      integ[y*iw+x]=integ[(y-1)*iw+x]+s;
    }
  }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}

// ----------------- Main UI wiring -----------------
input.addEventListener("change", async () => {
  corners = []; picking = false;
  basePoints = []; points = []; history = []; lastWarped = null;
  try{
    imgObj = await fileToImg(input.files[0]);
    drawSource();
    setOut("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –í—ã–±–µ—Ä–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏.", "warn");
  }catch(e){
    imgObj = null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "bad");
  }
  updateUI();
});

pickBtn.addEventListener("click", () => {
  corners = []; picking = true;
  setOut("–¢–∫–Ω–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏ (–õ–í‚Üí–ü–í‚Üí–ü–ù‚Üí–õ–ù).", "warn");
  drawSource(); updateUI();
});

cSrc.addEventListener("click", (ev) => {
  if (!picking) return;
  const r = cSrc.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cSrc.width  / r.width);
  const y = (ev.clientY - r.top)  * (cSrc.height / r.height);
  corners.push({x,y});
  drawSource();
  if (corners.length === 4){
    picking = false;
    setOut("–£–≥–ª—ã –≤—ã–±—Ä–∞–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  updateUI();
});

runBtn.addEventListener("click", () => {
  if (!imgObj || corners.length !== 4) return;

  setOut("–†–∞—Å–ø—Ä–µ–º–ª–µ–Ω–∏–µ –∏ blob-–∞–Ω–∞–ª–∏–∑‚Ä¶", "warn");

  const warped = warpToRect(cSrc, corners, RECT, RECT);
  lastWarped = warped;

  cRect.width = RECT; cRect.height = RECT;
  rectCtx.putImageData(warped, 0, 0);

  const s = parseInt(sens.value,10);
  const result = detectBlobsDoG(warped, RECT, RECT, s);

  basePoints = result.map(p => ({
    x:p.x, y:p.y, r:p.r, dMm:p.dMm,
    src:"auto",
    excluded:false
  }));

  history = [];
  setPoints(clonePts(basePoints));
  redrawRect();
});

// ----------------- Editing gestures on rect canvas -----------------
const PICK_R = 28;
let lastTapTime = 0;
let lastTapPos = null;

let dragging = false;
let dragIdx = -1;
let pressTimer = null;

function toggleAt(x,y){
  const idx = nearestPoint(x,y,PICK_R);
  if(idx < 0) return;
  pushHistory();
  points[idx].excluded = !points[idx].excluded;
  setPoints(points);
  redrawRect();
}

function addManualAt(x,y){
  pushHistory();
  const dMm = Math.max(6.0, DMIN_MM());     // default manual size
  const r = (dMm/2) / mmPerPx;
  points.push({x,y,r,dMm,src:"manual",excluded:false});
  setPoints(points);
  redrawRect();
}

function startDragAt(x,y){
  const idx = nearestPoint(x,y,PICK_R);
  if(idx < 0) return;
  dragging = true;
  dragIdx = idx;
  // –µ—Å–ª–∏ –¥–≤–∏–≥–∞–µ–º auto ‚Äî –¥–µ–ª–∞–µ–º manual (–∞—É–¥–∏—Ç)
  if(points[dragIdx].src === "auto") points[dragIdx].src = "manual";
}

function moveDragTo(x,y){
  if(!dragging || dragIdx<0) return;
  points[dragIdx].x = x;
  points[dragIdx].y = y;
  redrawRect();
}

function endDrag(){
  dragging = false; dragIdx = -1;
}

// Desktop mouse
cRect.addEventListener("mousedown", (ev)=>{
  if(!lastWarped) return;
  const p = canvasXY(ev, cRect);
  pressTimer = setTimeout(()=>{
    pushHistory();
    startDragAt(p.x,p.y);
  }, 180);
});
cRect.addEventListener("mousemove", (ev)=>{
  if(!lastWarped) return;
  const p = canvasXY(ev, cRect);
  if(dragging) moveDragTo(p.x,p.y);
});
cRect.addEventListener("mouseup", (ev)=>{
  if(!lastWarped) return;
  clearTimeout(pressTimer);
  const p = canvasXY(ev, cRect);

  if(dragging){
    endDrag();
    setPoints(points);
    redrawRect();
    return;
  }

  const now = Date.now();
  const isDouble = (now - lastTapTime) < 260 && lastTapPos && dist2(lastTapPos, p) < 18*18;
  lastTapTime = now; lastTapPos = p;

  if(isDouble) addManualAt(p.x,p.y);
  else toggleAt(p.x,p.y);
});

// iOS touch
cRect.addEventListener("touchstart", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();
  const t = ev.touches[0];
  const p = canvasXY(t, cRect);

  pressTimer = setTimeout(()=>{
    pushHistory();
    startDragAt(p.x,p.y);
  }, 180);

  const now = Date.now();
  const isDouble = (now - lastTapTime) < 260 && lastTapPos && dist2(lastTapPos, p) < 18*18;
  lastTapTime = now; lastTapPos = p;

  if(isDouble){
    clearTimeout(pressTimer);
    addManualAt(p.x,p.y);
  }
}, {passive:false});

cRect.addEventListener("touchmove", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();
  const t = ev.touches[0];
  const p = canvasXY(t, cRect);
  if(dragging) moveDragTo(p.x,p.y);
}, {passive:false});

cRect.addEventListener("touchend", (ev)=>{
  if(!lastWarped) return;
  ev.preventDefault();
  clearTimeout(pressTimer);

  if(dragging){
    endDrag();
    setPoints(points);
    redrawRect();
    return;
  }
  // single tap toggle –¥–µ–ª–∞–µ–º –Ω–µ –∑–¥–µ—Å—å, –∞ —á–µ—Ä–µ–∑ mouse/click; –Ω–∞ iOS single tap –æ–±—ã—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ ‚Äú–∫–ª–∏–∫‚Äù
}, {passive:false});

// Buttons
undoBtn.addEventListener("click", ()=>{
  if(!history.length) return;
  const prev = history.pop();
  points = JSON.parse(prev);
  setPoints(points);
  redrawRect();
});
clearManualBtn.addEventListener("click", ()=>{
  if(!points.length) return;
  pushHistory();
  points = points.filter(p => p.src !== "manual");
  setPoints(points);
  redrawRect();
});
resetEditsBtn.addEventListener("click", ()=>{
  history = [];
  setPoints(clonePts(basePoints));
  redrawRect();
});
exportBtn.addEventListener("click", ()=>{
  const payload = {
    version: "A1.8",
    frame_mm: FRAME_MM,
    rect_px: RECT,
    mm_per_px: mmPerPx,
    min_mm: DMIN_MM(),
    detect_max_mm: DMAX_DETECT_MM,
    sensitivity: parseInt(sens.value,10),
    points: points
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "mwc_a1_8_points.json";
  a.click();
});
savePngBtn.addEventListener("click", ()=>{
  if(!lastWarped) return;
  // —É–∂–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω–æ –Ω–∞ cRect, –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º canvas –∫–∞–∫ PNG
  const a = document.createElement("a");
  a.href = cRect.toDataURL("image/png");
  a.download = "mwc_a1_8_marked.png";
  a.click();
});

// init
sensVal.textContent = sens.value;
minmmVal.textContent = Number(minmm.value).toFixed(1);
updateUI();
</script>
</body>
</html>
