<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC ‚Äî A1.6 FINAL</title>
<meta name="theme-color" content="#111">
<style>
body{font-family:-apple-system,system-ui,Arial;margin:16px}
h1{font-size:20px;margin:0 0 8px}
.small{font-size:13px;color:#555;margin:6px 0}
.card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
button.secondary{background:#fff;color:#111}
button:disabled{opacity:.45}
input{width:100%;margin:8px 0}
pre{white-space:pre-wrap;margin:0}
canvas{width:100%;border:1px solid #ddd;border-radius:12px;touch-action:manipulation}
.ok{color:#0a7;font-weight:700}
.bad{color:#c00;font-weight:700}
.warn{color:#c90;font-weight:700}
.row{display:flex;gap:10px;flex-wrap:wrap}
.row > button{flex:1;min-width:160px}
</style>
</head>

<body>
<h1>MWC ‚Äî A1.6 FINAL (–ø–∏–Ω—ã 4‚Äì12 –º–º)</h1>
<div class="small">
–®–∞–≥–∏: 1) –≤—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ ‚Üí 2) —Ç–∫–Ω–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏ (–õ–í‚Üí–ü–í‚Üí–ü–ù‚Üí–õ–ù) ‚Üí 3) –ê–Ω–∞–ª–∏–∑.
</div>

<div class="card">
  <b>–§–æ—Ç–æ</b>
  <input id="img" type="file" accept="image/*">
  <div class="row">
    <button id="pick" class="secondary" disabled>–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞</button>
    <button id="run" disabled>–ê–Ω–∞–ª–∏–∑</button>
  </div>
  <div class="small" id="hint">–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.</div>
</div>

<div class="card"><pre id="out">–ó–∞–≥—Ä—É–∑–∏ —Ñ–æ—Ç–æ.</pre></div>

<div class="card">
  <b>–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ (–≤—ã–±–æ—Ä —É–≥–ª–æ–≤)</b>
  <canvas id="src"></canvas>
  <div class="small">–ü–æ—Ä—è–¥–æ–∫: 1) –õ–í  2) –ü–í  3) –ü–ù  4) –õ–ù</div>
</div>

<div class="card">
  <b>–†–∞—Å–ø—Ä–µ–º–ª—ë–Ω–Ω–∞—è —Ä–∞–º–∫–∞ (800√ó800)</b>
  <canvas id="rect"></canvas>
  <div class="small">üü¢ ‚Äî –∑–∞—Å—á–∏—Ç–∞–Ω–Ω—ã–µ –ø–∏–Ω—ã 4‚Äì12 –º–º</div>
</div>

<script>
const input = document.getElementById("img");
const pickBtn = document.getElementById("pick");
const runBtn  = document.getElementById("run");
const hint = document.getElementById("hint");
const out  = document.getElementById("out");
const cSrc = document.getElementById("src");
const cRect= document.getElementById("rect");
const srcCtx = cSrc.getContext("2d", { willReadFrequently:true });
const rectCtx= cRect.getContext("2d", { willReadFrequently:true });

let imgObj = null;
let picking = false;
let corners = [];

const RECT = 800;       // px
const FRAME_MM = 200;  // 20√ó20 —Å–º
const mmPerPx = FRAME_MM / RECT; // —Ç–æ—á–Ω—ã–π –º–∞—Å—à—Ç–∞–±

function setOut(t, cls=""){ out.className = cls; out.textContent = t; }
function updateUI(){
  pickBtn.disabled = !imgObj;
  runBtn.disabled = !(imgObj && corners.length === 4);
  if (!imgObj) hint.textContent = "–í—ã–±–µ—Ä–∏ —Ñ–æ—Ç–æ.";
  else if (corners.length < 4) hint.textContent = "–ù–∞–∂–º–∏ ¬´–í—ã–±—Ä–∞—Ç—å 4 —É–≥–ª–∞¬ª –∏ —Ç–∫–Ω–∏ 4 —É–≥–ª–∞.";
  else hint.textContent = "–ì–æ—Ç–æ–≤–æ. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.";
}

input.addEventListener("change", async () => {
  corners = []; picking = false;
  try{
    imgObj = await fileToImg(input.files[0]);
    drawSource();
    setOut("–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –í—ã–±–µ—Ä–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏.", "warn");
  }catch(e){
    imgObj = null;
    setOut("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ.", "bad");
  }
  updateUI();
});

pickBtn.addEventListener("click", () => {
  corners = []; picking = true;
  setOut("–¢–∫–Ω–∏ 4 —É–≥–ª–∞ —Ä–∞–º–∫–∏ (–õ–í‚Üí–ü–í‚Üí–ü–ù‚Üí–õ–ù).", "warn");
  drawSource(); updateUI();
});

cSrc.addEventListener("click", (ev) => {
  if (!picking) return;
  const r = cSrc.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (cSrc.width  / r.width);
  const y = (ev.clientY - r.top)  * (cSrc.height / r.height);
  corners.push({x,y});
  drawSource();
  if (corners.length === 4){
    picking = false;
    setOut("–£–≥–ª—ã –≤—ã–±—Ä–∞–Ω—ã. –ù–∞–∂–º–∏ ¬´–ê–Ω–∞–ª–∏–∑¬ª.", "ok");
  }
  updateUI();
});

runBtn.addEventListener("click", () => {
  if (!imgObj || corners.length !== 4) return;
  setOut("–†–∞—Å–ø—Ä–µ–º–ª–µ–Ω–∏–µ –∏ –∞–Ω–∞–ª–∏–∑‚Ä¶", "warn");

  // 1) Warp
  const warped = warpToRect(cSrc, corners, RECT, RECT);
  cRect.width = RECT; cRect.height = RECT;
  rectCtx.putImageData(warped, 0, 0);

  // 2) Analyze
  const res = analyzeRect(warped, RECT, RECT);

  // draw result
  rectCtx.putImageData(warped, 0, 0);
  rectCtx.lineWidth = 3;
  rectCtx.strokeStyle = "#00ff00";
  let sum = 0;
  for (const p of res){
    sum += p.dMm;
    rectCtx.beginPath();
    rectCtx.arc(p.cx, p.cy, Math.max(6, p.dPx/2), 0, Math.PI*2);
    rectCtx.stroke();
  }

  const n = res.length;
  const avg = n ? (sum/n).toFixed(1) : "0.0";
  setOut(`–ü–∏–Ω–æ–≤ 4‚Äì12 –º–º: ${n}\n–°—Ä–µ–¥–Ω–∏–π –¥–∏–∞–º–µ—Ç—Ä: ${avg} –º–º\n–ú–∞—Å—à—Ç–∞–±: ${mmPerPx.toFixed(4)} –º–º/px`, n?"ok":"bad");
});

// ---------- helpers ----------
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function drawSource(){
  const maxW = 1100;
  const sc = Math.min(1, maxW / imgObj.naturalWidth);
  const w = Math.round(imgObj.naturalWidth * sc);
  const h = Math.round(imgObj.naturalHeight * sc);
  cSrc.width = w; cSrc.height = h;
  srcCtx.drawImage(imgObj, 0, 0, w, h);

  if (corners.length){
    srcCtx.lineWidth = 4;
    srcCtx.strokeStyle = "#00ff00";
    srcCtx.fillStyle = "#00ff00";
    srcCtx.font = "20px system-ui";
    corners.forEach((p,i)=>{
      srcCtx.beginPath(); srcCtx.arc(p.x,p.y,8,0,Math.PI*2); srcCtx.fill();
      srcCtx.fillText(String(i+1), p.x+10, p.y-10);
    });
    if (corners.length===4){
      srcCtx.beginPath();
      srcCtx.moveTo(corners[0].x,corners[0].y);
      for(let i=1;i<4;i++) srcCtx.lineTo(corners[i].x,corners[i].y);
      srcCtx.closePath(); srcCtx.stroke();
    }
  }
}

// ---------- perspective warp ----------
function warpToRect(sourceCanvas, srcPts, dstW, dstH){
  const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
  const H = computeHomography(dstPts, srcPts); // dst -> src

  const sCtx = sourceCanvas.getContext("2d", { willReadFrequently:true });
  const sW = sourceCanvas.width, sH = sourceCanvas.height;
  const sData = sCtx.getImageData(0,0,sW,sH).data;

  const out = new ImageData(dstW, dstH);
  const o = out.data;

  for(let y=0;y<dstH;y++){
    for(let x=0;x<dstW;x++){
      const [sx, sy] = applyH(H, x, y);
      const ix = Math.floor(sx), iy = Math.floor(sy);
      const di = (y*dstW + x)*4;
      if (ix>=0 && iy>=0 && ix<sW && iy<sH){
        const si = (iy*sW + ix)*4;
        o[di]=sData[si]; o[di+1]=sData[si+1]; o[di+2]=sData[si+2]; o[di+3]=255;
      } else { o[di]=o[di+1]=o[di+2]=0; o[di+3]=255; }
    }
  }
  return out;
}
function applyH(H, x, y){
  const a = H[0]*x + H[1]*y + H[2];
  const b = H[3]*x + H[4]*y + H[5];
  const c = H[6]*x + H[7]*y + H[8];
  return [a/c, b/c];
}
function computeHomography(p, q){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const x=p[i].x, y=p[i].y, u=q[i].x, v=q[i].y;
    A.push([x,y,1,0,0,0,-x*u,-y*u]); b.push(u);
    A.push([0,0,0,x,y,1,-x*v,-y*v]); b.push(v);
  }
  const h = solve8(A,b);
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7],1];
}
function solve8(A,b){
  const n=8, M=A.map((r,i)=>r.concat([b[i]]));
  for(let c=0;c<n;c++){
    let p=c; for(let r=c+1;r<n;r++) if(Math.abs(M[r][c])>Math.abs(M[p][c])) p=r;
    [M[c],M[p]]=[M[p],M[c]];
    const d=M[c][c]||1e-12; for(let j=c;j<=n;j++) M[c][j]/=d;
    for(let r=0;r<n;r++){ if(r===c) continue; const f=M[r][c]; for(let j=c;j<=n;j++) M[r][j]-=f*M[c][j]; }
  }
  return M.map(r=>r[n]);
}

// ---------- analysis ----------
function analyzeRect(imageData, w, h){
  const d=imageData.data;
  const gray=new Float32Array(w*h);
  for(let i=0;i<w*h;i++) gray[i]=0.2126*d[i*4]+0.7152*d[i*4+1]+0.0722*d[i*4+2];

  // local background
  const bg = boxBlur(gray,w,h,18);
  let bin=new Uint8Array(w*h);
  for(let i=0;i<w*h;i++) bin[i]=(gray[i]>bg[i]+18)?1:0;
  bin = erode(dilate(bin,w,h),w,h);

  const comps = cc(bin,w,h);
  const pins=[];
  for(const c of comps){
    if(c.area<18) continue;
    const circ=(c.per>0)?(4*Math.PI*c.area/(c.per*c.per)):0;
    if(circ<0.28) continue;
    const dPx=2*Math.sqrt(c.area/Math.PI);
    const dMm=dPx*mmPerPx;
    if(dMm>=4 && dMm<=12) pins.push({cx:c.cx,cy:c.cy,dPx,dMm});
  }
  return pins;
}
function boxBlur(src,w,h,r){
  const dst=new Float32Array(w*h), iw=w+1, integ=new Float32Array((w+1)*(h+1));
  for(let y=1;y<=h;y++){ let s=0; for(let x=1;x<=w;x++){ s+=src[(y-1)*w+(x-1)]; integ[y*iw+x]=integ[(y-1)*iw+x]+s; } }
  for(let y=0;y<h;y++){
    const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    for(let x=0;x<w;x++){
      const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      const A=integ[y0*iw+x0], B=integ[y0*iw+x1+1], C=integ[(y1+1)*iw+x0], D=integ[(y1+1)*iw+x1+1];
      dst[y*w+x]=(D-B-C+A)/((x1-x0+1)*(y1-y0+1));
    }
  }
  return dst;
}
function dilate(b,w,h){ const o=new Uint8Array(w*h);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ const p=y*w+x;
    o[p]=b[p]||b[p-1]||b[p+1]||b[p-w]||b[p+w]||b[p-w-1]||b[p-w+1]||b[p+w-1]||b[p+w+1]?1:0;}
  return o;
}
function erode(b,w,h){ const o=new Uint8Array(w*h);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ const p=y*w+x;
    o[p]=b[p]&&b[p-1]&&b[p+1]&&b[p-w]&&b[p+w]&&b[p-w-1]&&b[p-w+1]&&b[p+w-1]&&b[p+w+1]?1:0;}
  return o;
}
function cc(b,w,h){
  const v=new Uint8Array(w*h), st=[], res=[], id=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ const p=id(x,y);
    if(!b[p]||v[p]) continue; let a=0,sx=0,sy=0,per=0; st.length=0; st.push(p); v[p]=1;
    while(st.length){ const q=st.pop(), qy=(q/w)|0, qx=q-qy*w; a++; sx+=qx; sy+=qy;
      const n1=q-1,n2=q+1,n3=q-w,n4=q+w; if(!b[n1])per++; if(!b[n2])per++; if(!b[n3])per++; if(!b[n4])per++;
      if(b[n1]&&!v[n1]){v[n1]=1;st.push(n1)} if(b[n2]&&!v[n2]){v[n2]=1;st.push(n2)}
      if(b[n3]&&!v[n3]){v[n3]=1;st.push(n3)} if(b[n4]&&!v[n4]){v[n4]=1;st.push(n4)}
    }
    res.push({area:a,cx:sx/a,cy:sy/a,per});
  }
  return res;
}
</script>
</body>
</html>
