<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MWC — A1</title>
<meta name="theme-color" content="#111111">
<style>
  body{font-family:-apple-system,system-ui,Arial;margin:16px}
  h1{font-size:20px;margin:0 0 8px}
  .small{font-size:13px;color:#555;margin:6px 0}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:10px 0}
  button{width:100%;padding:12px;border-radius:10px;border:1px solid #111;background:#111;color:#fff;font-weight:800}
  button:disabled{opacity:.45}
  input{width:100%;margin:8px 0}
  pre{white-space:pre-wrap;margin:0}
  canvas{width:100%;border:1px solid #ddd;border-radius:12px}
  .ok{color:#0a7;font-weight:700}
  .warn{color:#c90;font-weight:700}
  .bad{color:#c00;font-weight:700}
  .ghost{background:#fff;color:#111}
</style>
</head>

<body>
<h1>MWC — A1 (пины &gt;4 мм)</h1>
<div class="small">
Открыто из Safari. Если OpenCV не готов — нажми «Перезагрузить OpenCV».
</div>

<div class="card">
  <b>Выбери фото</b>
  <input id="img" type="file" accept="image/*">
  <button id="btn" disabled>АНАЛИЗ</button>
  <button id="reload" class="ghost" style="margin-top:8px; display:none;">Перезагрузить OpenCV</button>
  <div class="small" id="hint">Загрузка OpenCV…</div>
</div>

<div class="card"><pre id="out">Загрузи фото.</pre></div>

<div class="card">
  <canvas id="cv"></canvas>
  <div class="small">Найденные пины &gt;4 мм обведены зелёным.</div>
</div>

<script>
const input = document.getElementById("img");
const btn   = document.getElementById("btn");
const out   = document.getElementById("out");
const hint  = document.getElementById("hint");
const reloadBtn = document.getElementById("reload");
const canvas= document.getElementById("cv");

let cvIsReady = false;

function set(t, cls=""){ out.className = cls; out.textContent = t; }
function hasFile(){ return input.files && input.files[0]; }

function updateUI(){
  btn.disabled = !(cvIsReady && hasFile());
  if (!cvIsReady) hint.textContent = "Жду загрузки OpenCV… (иногда 30–90 сек в первый раз)";
  else if (!hasFile()) hint.textContent = "OpenCV готов. Выбери фото.";
  else hint.textContent = "Готово. Нажми «АНАЛИЗ».";
}

// --- OpenCV loader with fallback CDN ---
function loadScript(src){
  return new Promise((resolve, reject) => {
    const s = document.createElement("script");
    s.async = true;
    s.src = src;
    s.onload = () => resolve();
    s.onerror = () => reject(new Error("load failed: " + src));
    document.head.appendChild(s);
  });
}

async function loadOpenCV(){
  cvIsReady = false;
  updateUI();
  reloadBtn.style.display = "none";

  // cleanup previous script tags (optional)
  [...document.querySelectorAll("script[data-opencv]")].forEach(x => x.remove());

  const v = Date.now();
  const sources = [
    `https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.js?v=${v}`,
    `https://unpkg.com/opencv.js@1.2.1/opencv.js?v=${v}`
  ];

  let loaded = false;
  for (const src of sources){
    try{
      const s = document.createElement("script");
      s.async = true;
      s.src = src;
      s.setAttribute("data-opencv","1");
      document.head.appendChild(s);

      await new Promise((resolve, reject) => {
        s.onload = resolve;
        s.onerror = reject;
      });

      loaded = true;
      break;
    }catch(e){
      // try next source
    }
  }

  if (!loaded){
    hint.textContent = "Не удалось загрузить OpenCV. Проверь интернет/блокировщик и нажми «Перезагрузить OpenCV».";
    reloadBtn.style.display = "block";
    return;
  }

  // wait runtime init
  if (typeof cv === "undefined"){
    hint.textContent = "OpenCV скрипт загрузился, но cv не появился. Нажми «Перезагрузить OpenCV».";
    reloadBtn.style.display = "block";
    return;
  }

  cv["onRuntimeInitialized"] = () => {
    cvIsReady = true;
    reloadBtn.style.display = "none";
    updateUI();
  };

  // if still not ready after 25s -> show reload
  setTimeout(() => { if (!cvIsReady) reloadBtn.style.display = "block"; }, 25000);
}

reloadBtn.addEventListener("click", () => loadOpenCV());

input.addEventListener("change", () => {
  if (hasFile()) set("Фото выбрано. Нажми «АНАЛИЗ».");
  else set("Загрузи фото.");
  updateUI();
});

// --- helpers ---
function fileToImg(f){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = URL.createObjectURL(f);
  });
}

function matFromImg(i){
  const c = document.createElement("canvas");
  c.width = i.naturalWidth;
  c.height = i.naturalHeight;
  c.getContext("2d").drawImage(i, 0, 0);
  const ctx = c.getContext("2d");
  const id = ctx.getImageData(0,0,c.width,c.height);
  return cv.matFromImageData(id);
}

function drawRGBA(matRGBA){
  canvas.width = matRGBA.cols;
  canvas.height = matRGBA.rows;
  const imgData = new ImageData(new Uint8ClampedArray(matRGBA.data), matRGBA.cols, matRGBA.rows);
  canvas.getContext("2d").putImageData(imgData, 0, 0);
}

// --- analysis ---
btn.addEventListener("click", async () => {
  if (btn.disabled) return;
  btn.disabled = true;
  set("Анализ…");

  try {
    const img = await fileToImg(input.files[0]);
    const mat = matFromImg(img);

    const gray = new cv.Mat();
    cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);

    const bin = new cv.Mat();
    cv.threshold(gray, bin, 200, 255, cv.THRESH_BINARY);

    const k = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
    cv.morphologyEx(bin, bin, cv.MORPH_OPEN, k);
    cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k);

    const cont = new cv.MatVector();
    const hier = new cv.Mat();
    cv.findContours(bin, cont, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // A1: пока мм приблизительно
    const mmPerPx = 200/800;

    let count = 0, sum = 0;
    const outMat = mat.clone();

    for (let i=0; i<cont.size(); i++){
      const c = cont.get(i);
      const area = cv.contourArea(c);
      if (area < 30) { c.delete(); continue; }

      const peri = cv.arcLength(c, true);
      const circ = (peri>0) ? (4*Math.PI*area/(peri*peri)) : 0;
      if (circ < 0.55) { c.delete(); continue; }

      const dpx = 2 * Math.sqrt(area / Math.PI);
      const dmm = dpx * mmPerPx;

      if (dmm >= 4){
        const m = cv.moments(c);
        const x = m.m10 / m.m00;
        const y = m.m01 / m.m00;
        cv.circle(outMat, new cv.Point(x,y), Math.max(6, dpx/2), new cv.Scalar(0,255,0,255), 2);
        count++; sum += dmm;
      }
      c.delete();
    }

    const avg = count ? (sum/count).toFixed(1) : "0.0";
    set(`Пинов >4 мм: ${count}\nСредний диаметр: ${avg} мм`, count ? "ok" : "bad");
    drawRGBA(outMat);

    mat.delete(); gray.delete(); bin.delete(); k.delete(); cont.delete(); hier.delete(); outMat.delete();
  } catch (e) {
    set("Ошибка анализа: " + String(e), "bad");
  } finally {
    updateUI();
  }
});

updateUI();
loadOpenCV();
</script>
</body>
</html>
